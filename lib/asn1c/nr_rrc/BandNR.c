/*
 * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
 * From ASN.1 module "NR-RRC-Definitions"
 * 	found in "NR-RRC-Definitions.asn"
 * 	`asn1c -fcompound-names -no-gen-example -pdu=all`
 */

#include "BandNR.h"

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static int
memb_scs_15kHz_constraint_30(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 10)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_30kHz_constraint_30(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 10)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_60kHz_constraint_30(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 10)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_60kHz_constraint_34(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 3)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_120kHz_constraint_34(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 3)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_15kHz_constraint_38(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 10)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_30kHz_constraint_38(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 10)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_60kHz_constraint_38(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 10)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_60kHz_constraint_42(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 3)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_120kHz_constraint_42(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 3)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static int
memb_scs_15kHz_constraint_69(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 16)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_30kHz_constraint_69(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 16)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_60kHz_constraint_69(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 16)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_60kHz_constraint_73(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 8)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_120kHz_constraint_73(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 8)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_15kHz_constraint_77(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 16)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_30kHz_constraint_77(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 16)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_60kHz_constraint_77(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 16)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_60kHz_constraint_81(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 8)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_scs_120kHz_constraint_81(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 8)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static int
memb_maxNumberPatterns_r16_constraint_88(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 2 && value <= 6)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_maxNumberNon_OverlapPatterns_r16_constraint_88(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 3)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static int
memb_maxNumberConfigsAllCC_r16_constraint_143(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 2 && value <= 32)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static int
memb_maxNumberConfigsPerBWP_r16_constraint_153(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 8)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_maxNumberConfigsAllCC_r16_constraint_153(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 2 && value <= 32)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static int
memb_modifiedMPR_Behaviour_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size == 8)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_asymmetricBandwidthCombinationSet_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(st->size > 0) {
		/* Size in bits */
		size = 8 * st->size - (st->bits_unused & 0x07);
	} else {
		size = 0;
	}
	
	if((size >= 1 && size <= 32)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static asn_oer_constraints_t asn_OER_type_extendedCP_constr_5 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_extendedCP_constr_5 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_multipleTCI_constr_7 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_multipleTCI_constr_7 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_bwp_WithoutRestriction_constr_9 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_bwp_WithoutRestriction_constr_9 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_bwp_SameNumerology_constr_11 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_bwp_SameNumerology_constr_11 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 1,  1,  0,  1 }	/* (0..1) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_bwp_DiffNumerology_constr_14 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_bwp_DiffNumerology_constr_14 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_crossCarrierScheduling_SameSCS_constr_16 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_crossCarrierScheduling_SameSCS_constr_16 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_pdsch_256QAM_FR2_constr_18 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_pdsch_256QAM_FR2_constr_18 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_pusch_256QAM_constr_20 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_pusch_256QAM_constr_20 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_ue_PowerClass_constr_22 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_ue_PowerClass_constr_22 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  3 }	/* (0..3) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_rateMatchingLTE_CRS_constr_27 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_rateMatchingLTE_CRS_constr_27 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_15kHz_constr_31 CC_NOTUSED = {
	{ 0, 0 },
	10	/* (SIZE(10..10)) */};
static asn_per_constraints_t asn_PER_memb_scs_15kHz_constr_31 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  10,  10 }	/* (SIZE(10..10)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_30kHz_constr_32 CC_NOTUSED = {
	{ 0, 0 },
	10	/* (SIZE(10..10)) */};
static asn_per_constraints_t asn_PER_memb_scs_30kHz_constr_32 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  10,  10 }	/* (SIZE(10..10)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_60kHz_constr_33 CC_NOTUSED = {
	{ 0, 0 },
	10	/* (SIZE(10..10)) */};
static asn_per_constraints_t asn_PER_memb_scs_60kHz_constr_33 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  10,  10 }	/* (SIZE(10..10)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_60kHz_constr_35 CC_NOTUSED = {
	{ 0, 0 },
	3	/* (SIZE(3..3)) */};
static asn_per_constraints_t asn_PER_memb_scs_60kHz_constr_35 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  3,  3 }	/* (SIZE(3..3)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_120kHz_constr_36 CC_NOTUSED = {
	{ 0, 0 },
	3	/* (SIZE(3..3)) */};
static asn_per_constraints_t asn_PER_memb_scs_120kHz_constr_36 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  3,  3 }	/* (SIZE(3..3)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_channelBWs_DL_constr_29 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_channelBWs_DL_constr_29 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 1,  1,  0,  1 }	/* (0..1) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_15kHz_constr_39 CC_NOTUSED = {
	{ 0, 0 },
	10	/* (SIZE(10..10)) */};
static asn_per_constraints_t asn_PER_memb_scs_15kHz_constr_39 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  10,  10 }	/* (SIZE(10..10)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_30kHz_constr_40 CC_NOTUSED = {
	{ 0, 0 },
	10	/* (SIZE(10..10)) */};
static asn_per_constraints_t asn_PER_memb_scs_30kHz_constr_40 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  10,  10 }	/* (SIZE(10..10)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_60kHz_constr_41 CC_NOTUSED = {
	{ 0, 0 },
	10	/* (SIZE(10..10)) */};
static asn_per_constraints_t asn_PER_memb_scs_60kHz_constr_41 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  10,  10 }	/* (SIZE(10..10)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_60kHz_constr_43 CC_NOTUSED = {
	{ 0, 0 },
	3	/* (SIZE(3..3)) */};
static asn_per_constraints_t asn_PER_memb_scs_60kHz_constr_43 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  3,  3 }	/* (SIZE(3..3)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_120kHz_constr_44 CC_NOTUSED = {
	{ 0, 0 },
	3	/* (SIZE(3..3)) */};
static asn_per_constraints_t asn_PER_memb_scs_120kHz_constr_44 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  3,  3 }	/* (SIZE(3..3)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_channelBWs_UL_constr_37 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_channelBWs_UL_constr_37 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 1,  1,  0,  1 }	/* (0..1) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_maxUplinkDutyCycle_PC2_FR1_constr_46 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_maxUplinkDutyCycle_PC2_FR1_constr_46 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  0,  4 }	/* (0..4) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_pucch_SpatialRelInfoMAC_CE_constr_52 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_pucch_SpatialRelInfoMAC_CE_constr_52 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_powerBoosting_pi2BPSK_constr_54 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_powerBoosting_pi2BPSK_constr_54 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_maxUplinkDutyCycle_FR2_constr_56 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_maxUplinkDutyCycle_FR2_constr_56 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 4,  4,  0,  10 }	/* (0..10) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_15kHz_constr_70 CC_NOTUSED = {
	{ 0, 0 },
	16	/* (SIZE(16..16)) */};
static asn_per_constraints_t asn_PER_memb_scs_15kHz_constr_70 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  16,  16 }	/* (SIZE(16..16)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_30kHz_constr_71 CC_NOTUSED = {
	{ 0, 0 },
	16	/* (SIZE(16..16)) */};
static asn_per_constraints_t asn_PER_memb_scs_30kHz_constr_71 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  16,  16 }	/* (SIZE(16..16)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_60kHz_constr_72 CC_NOTUSED = {
	{ 0, 0 },
	16	/* (SIZE(16..16)) */};
static asn_per_constraints_t asn_PER_memb_scs_60kHz_constr_72 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  16,  16 }	/* (SIZE(16..16)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_60kHz_constr_74 CC_NOTUSED = {
	{ 0, 0 },
	8	/* (SIZE(8..8)) */};
static asn_per_constraints_t asn_PER_memb_scs_60kHz_constr_74 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  8,  8 }	/* (SIZE(8..8)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_120kHz_constr_75 CC_NOTUSED = {
	{ 0, 0 },
	8	/* (SIZE(8..8)) */};
static asn_per_constraints_t asn_PER_memb_scs_120kHz_constr_75 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  8,  8 }	/* (SIZE(8..8)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_channelBWs_DL_v1590_constr_68 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_channelBWs_DL_v1590_constr_68 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 1,  1,  0,  1 }	/* (0..1) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_15kHz_constr_78 CC_NOTUSED = {
	{ 0, 0 },
	16	/* (SIZE(16..16)) */};
static asn_per_constraints_t asn_PER_memb_scs_15kHz_constr_78 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  16,  16 }	/* (SIZE(16..16)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_30kHz_constr_79 CC_NOTUSED = {
	{ 0, 0 },
	16	/* (SIZE(16..16)) */};
static asn_per_constraints_t asn_PER_memb_scs_30kHz_constr_79 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  16,  16 }	/* (SIZE(16..16)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_60kHz_constr_80 CC_NOTUSED = {
	{ 0, 0 },
	16	/* (SIZE(16..16)) */};
static asn_per_constraints_t asn_PER_memb_scs_60kHz_constr_80 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  16,  16 }	/* (SIZE(16..16)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_60kHz_constr_82 CC_NOTUSED = {
	{ 0, 0 },
	8	/* (SIZE(8..8)) */};
static asn_per_constraints_t asn_PER_memb_scs_60kHz_constr_82 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  8,  8 }	/* (SIZE(8..8)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_scs_120kHz_constr_83 CC_NOTUSED = {
	{ 0, 0 },
	8	/* (SIZE(8..8)) */};
static asn_per_constraints_t asn_PER_memb_scs_120kHz_constr_83 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  8,  8 }	/* (SIZE(8..8)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_channelBWs_UL_v1590_constr_76 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_channelBWs_UL_v1590_constr_76 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 1,  1,  0,  1 }	/* (0..1) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_cancelOverlappingPUSCH_r16_constr_86 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_cancelOverlappingPUSCH_r16_constr_86 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_maxNumberPatterns_r16_constr_89 CC_NOTUSED = {
	{ 1, 1 }	/* (2..6) */,
	-1};
static asn_per_constraints_t asn_PER_memb_maxNumberPatterns_r16_constr_89 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  2,  6 }	/* (2..6) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_maxNumberNon_OverlapPatterns_r16_constr_90 CC_NOTUSED = {
	{ 1, 1 }	/* (1..3) */,
	-1};
static asn_per_constraints_t asn_PER_memb_maxNumberNon_OverlapPatterns_r16_constr_90 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  1,  3 }	/* (1..3) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_overlapRateMatchingEUTRA_CRS_r16_constr_91 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_overlapRateMatchingEUTRA_CRS_r16_constr_91 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_pdsch_MappingTypeB_Alt_r16_constr_93 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_pdsch_MappingTypeB_Alt_r16_constr_93 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_oneSlotPeriodicTRS_r16_constr_95 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_oneSlotPeriodicTRS_r16_constr_95 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_simulSRS_MIMO_TransWithinBand_r16_constr_99 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_simulSRS_MIMO_TransWithinBand_r16_constr_99 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_scs_15kHz_constr_103 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_scs_15kHz_constr_103 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_scs_30kHz_constr_105 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_scs_30kHz_constr_105 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_scs_60kHz_constr_107 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_scs_60kHz_constr_107 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_scs_60kHz_constr_110 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_scs_60kHz_constr_110 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_scs_120kHz_constr_112 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_scs_120kHz_constr_112 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_channelBW_DL_IAB_r16_constr_101 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_channelBW_DL_IAB_r16_constr_101 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 1,  1,  0,  1 }	/* (0..1) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_scs_15kHz_constr_116 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_scs_15kHz_constr_116 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_scs_30kHz_constr_118 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_scs_30kHz_constr_118 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_scs_60kHz_constr_120 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_scs_60kHz_constr_120 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_scs_60kHz_constr_123 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_scs_60kHz_constr_123 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_scs_120kHz_constr_125 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_scs_120kHz_constr_125 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_channelBW_UL_IAB_r16_constr_114 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_channelBW_UL_IAB_r16_constr_114 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 1,  1,  0,  1 }	/* (0..1) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_rasterShift7dot5_IAB_r16_constr_127 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_rasterShift7dot5_IAB_r16_constr_127 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_ue_PowerClass_v1610_constr_129 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_ue_PowerClass_v1610_constr_129 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_condHandover_r16_constr_131 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_condHandover_r16_constr_131 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_condHandoverFailure_r16_constr_133 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_condHandoverFailure_r16_constr_133 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_condHandoverTwoTriggerEvents_r16_constr_135 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_condHandoverTwoTriggerEvents_r16_constr_135 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_condPSCellChange_r16_constr_137 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_condPSCellChange_r16_constr_137 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_condPSCellChangeTwoTriggerEvents_r16_constr_139 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_condPSCellChangeTwoTriggerEvents_r16_constr_139 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_mpr_PowerBoost_FR2_r16_constr_141 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_mpr_PowerBoost_FR2_r16_constr_141 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_maxNumberConfigsPerBWP_r16_constr_144 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_maxNumberConfigsPerBWP_r16_constr_144 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  0,  4 }	/* (0..4) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_maxNumberConfigsAllCC_r16_constr_150 CC_NOTUSED = {
	{ 1, 1 }	/* (2..32) */,
	-1};
static asn_per_constraints_t asn_PER_memb_maxNumberConfigsAllCC_r16_constr_150 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 5,  5,  2,  32 }	/* (2..32) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_jointReleaseConfiguredGrantType2_r16_constr_151 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_jointReleaseConfiguredGrantType2_r16_constr_151 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_maxNumberConfigsPerBWP_r16_constr_154 CC_NOTUSED = {
	{ 1, 1 }	/* (1..8) */,
	-1};
static asn_per_constraints_t asn_PER_memb_maxNumberConfigsPerBWP_r16_constr_154 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  1,  8 }	/* (1..8) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_maxNumberConfigsAllCC_r16_constr_155 CC_NOTUSED = {
	{ 1, 1 }	/* (2..32) */,
	-1};
static asn_per_constraints_t asn_PER_memb_maxNumberConfigsAllCC_r16_constr_155 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 5,  5,  2,  32 }	/* (2..32) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_jointReleaseSPS_r16_constr_156 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_jointReleaseSPS_r16_constr_156 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_simulSRS_TransWithinBand_r16_constr_158 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_simulSRS_TransWithinBand_r16_constr_158 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_trs_AdditionalBandwidth_r16_constr_160 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_trs_AdditionalBandwidth_r16_constr_160 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 1,  1,  0,  1 }	/* (0..1) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_type_handoverIntraF_IAB_r16_constr_163 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_type_handoverIntraF_IAB_r16_constr_163 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_modifiedMPR_Behaviour_constr_3 CC_NOTUSED = {
	{ 0, 0 },
	8	/* (SIZE(8..8)) */};
static asn_per_constraints_t asn_PER_memb_modifiedMPR_Behaviour_constr_3 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 0,  0,  8,  8 }	/* (SIZE(8..8)) */,
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_asymmetricBandwidthCombinationSet_constr_84 CC_NOTUSED = {
	{ 0, 0 },
	-1	/* (SIZE(1..32)) */};
static asn_per_constraints_t asn_PER_memb_asymmetricBandwidthCombinationSet_constr_84 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 5,  5,  1,  32 }	/* (SIZE(1..32)) */,
	0, 0	/* No PER value map */
};
static const asn_INTEGER_enum_map_t asn_MAP_extendedCP_value2enum_5[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_extendedCP_enum2value_5[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_extendedCP_specs_5 = {
	asn_MAP_extendedCP_value2enum_5,	/* "tag" => N; sorted by tag */
	asn_MAP_extendedCP_enum2value_5,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_extendedCP_tags_5[] = {
	(ASN_TAG_CLASS_CONTEXT | (3 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extendedCP_5 = {
	"extendedCP",
	"extendedCP",
	&asn_OP_NativeEnumerated,
	asn_DEF_extendedCP_tags_5,
	sizeof(asn_DEF_extendedCP_tags_5)
		/sizeof(asn_DEF_extendedCP_tags_5[0]) - 1, /* 1 */
	asn_DEF_extendedCP_tags_5,	/* Same as above */
	sizeof(asn_DEF_extendedCP_tags_5)
		/sizeof(asn_DEF_extendedCP_tags_5[0]), /* 2 */
	{ &asn_OER_type_extendedCP_constr_5, &asn_PER_type_extendedCP_constr_5, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_extendedCP_specs_5	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_multipleTCI_value2enum_7[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_multipleTCI_enum2value_7[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_multipleTCI_specs_7 = {
	asn_MAP_multipleTCI_value2enum_7,	/* "tag" => N; sorted by tag */
	asn_MAP_multipleTCI_enum2value_7,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_multipleTCI_tags_7[] = {
	(ASN_TAG_CLASS_CONTEXT | (4 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_multipleTCI_7 = {
	"multipleTCI",
	"multipleTCI",
	&asn_OP_NativeEnumerated,
	asn_DEF_multipleTCI_tags_7,
	sizeof(asn_DEF_multipleTCI_tags_7)
		/sizeof(asn_DEF_multipleTCI_tags_7[0]) - 1, /* 1 */
	asn_DEF_multipleTCI_tags_7,	/* Same as above */
	sizeof(asn_DEF_multipleTCI_tags_7)
		/sizeof(asn_DEF_multipleTCI_tags_7[0]), /* 2 */
	{ &asn_OER_type_multipleTCI_constr_7, &asn_PER_type_multipleTCI_constr_7, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_multipleTCI_specs_7	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_bwp_WithoutRestriction_value2enum_9[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_bwp_WithoutRestriction_enum2value_9[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_bwp_WithoutRestriction_specs_9 = {
	asn_MAP_bwp_WithoutRestriction_value2enum_9,	/* "tag" => N; sorted by tag */
	asn_MAP_bwp_WithoutRestriction_enum2value_9,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_bwp_WithoutRestriction_tags_9[] = {
	(ASN_TAG_CLASS_CONTEXT | (5 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_bwp_WithoutRestriction_9 = {
	"bwp-WithoutRestriction",
	"bwp-WithoutRestriction",
	&asn_OP_NativeEnumerated,
	asn_DEF_bwp_WithoutRestriction_tags_9,
	sizeof(asn_DEF_bwp_WithoutRestriction_tags_9)
		/sizeof(asn_DEF_bwp_WithoutRestriction_tags_9[0]) - 1, /* 1 */
	asn_DEF_bwp_WithoutRestriction_tags_9,	/* Same as above */
	sizeof(asn_DEF_bwp_WithoutRestriction_tags_9)
		/sizeof(asn_DEF_bwp_WithoutRestriction_tags_9[0]), /* 2 */
	{ &asn_OER_type_bwp_WithoutRestriction_constr_9, &asn_PER_type_bwp_WithoutRestriction_constr_9, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_bwp_WithoutRestriction_specs_9	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_bwp_SameNumerology_value2enum_11[] = {
	{ 0,	5,	"upto2" },
	{ 1,	5,	"upto4" }
};
static const unsigned int asn_MAP_bwp_SameNumerology_enum2value_11[] = {
	0,	/* upto2(0) */
	1	/* upto4(1) */
};
static const asn_INTEGER_specifics_t asn_SPC_bwp_SameNumerology_specs_11 = {
	asn_MAP_bwp_SameNumerology_value2enum_11,	/* "tag" => N; sorted by tag */
	asn_MAP_bwp_SameNumerology_enum2value_11,	/* N => "tag"; sorted by N */
	2,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_bwp_SameNumerology_tags_11[] = {
	(ASN_TAG_CLASS_CONTEXT | (6 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_bwp_SameNumerology_11 = {
	"bwp-SameNumerology",
	"bwp-SameNumerology",
	&asn_OP_NativeEnumerated,
	asn_DEF_bwp_SameNumerology_tags_11,
	sizeof(asn_DEF_bwp_SameNumerology_tags_11)
		/sizeof(asn_DEF_bwp_SameNumerology_tags_11[0]) - 1, /* 1 */
	asn_DEF_bwp_SameNumerology_tags_11,	/* Same as above */
	sizeof(asn_DEF_bwp_SameNumerology_tags_11)
		/sizeof(asn_DEF_bwp_SameNumerology_tags_11[0]), /* 2 */
	{ &asn_OER_type_bwp_SameNumerology_constr_11, &asn_PER_type_bwp_SameNumerology_constr_11, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_bwp_SameNumerology_specs_11	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_bwp_DiffNumerology_value2enum_14[] = {
	{ 0,	5,	"upto4" }
};
static const unsigned int asn_MAP_bwp_DiffNumerology_enum2value_14[] = {
	0	/* upto4(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_bwp_DiffNumerology_specs_14 = {
	asn_MAP_bwp_DiffNumerology_value2enum_14,	/* "tag" => N; sorted by tag */
	asn_MAP_bwp_DiffNumerology_enum2value_14,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_bwp_DiffNumerology_tags_14[] = {
	(ASN_TAG_CLASS_CONTEXT | (7 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_bwp_DiffNumerology_14 = {
	"bwp-DiffNumerology",
	"bwp-DiffNumerology",
	&asn_OP_NativeEnumerated,
	asn_DEF_bwp_DiffNumerology_tags_14,
	sizeof(asn_DEF_bwp_DiffNumerology_tags_14)
		/sizeof(asn_DEF_bwp_DiffNumerology_tags_14[0]) - 1, /* 1 */
	asn_DEF_bwp_DiffNumerology_tags_14,	/* Same as above */
	sizeof(asn_DEF_bwp_DiffNumerology_tags_14)
		/sizeof(asn_DEF_bwp_DiffNumerology_tags_14[0]), /* 2 */
	{ &asn_OER_type_bwp_DiffNumerology_constr_14, &asn_PER_type_bwp_DiffNumerology_constr_14, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_bwp_DiffNumerology_specs_14	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_crossCarrierScheduling_SameSCS_value2enum_16[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_crossCarrierScheduling_SameSCS_enum2value_16[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_crossCarrierScheduling_SameSCS_specs_16 = {
	asn_MAP_crossCarrierScheduling_SameSCS_value2enum_16,	/* "tag" => N; sorted by tag */
	asn_MAP_crossCarrierScheduling_SameSCS_enum2value_16,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_crossCarrierScheduling_SameSCS_tags_16[] = {
	(ASN_TAG_CLASS_CONTEXT | (8 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_crossCarrierScheduling_SameSCS_16 = {
	"crossCarrierScheduling-SameSCS",
	"crossCarrierScheduling-SameSCS",
	&asn_OP_NativeEnumerated,
	asn_DEF_crossCarrierScheduling_SameSCS_tags_16,
	sizeof(asn_DEF_crossCarrierScheduling_SameSCS_tags_16)
		/sizeof(asn_DEF_crossCarrierScheduling_SameSCS_tags_16[0]) - 1, /* 1 */
	asn_DEF_crossCarrierScheduling_SameSCS_tags_16,	/* Same as above */
	sizeof(asn_DEF_crossCarrierScheduling_SameSCS_tags_16)
		/sizeof(asn_DEF_crossCarrierScheduling_SameSCS_tags_16[0]), /* 2 */
	{ &asn_OER_type_crossCarrierScheduling_SameSCS_constr_16, &asn_PER_type_crossCarrierScheduling_SameSCS_constr_16, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_crossCarrierScheduling_SameSCS_specs_16	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_pdsch_256QAM_FR2_value2enum_18[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_pdsch_256QAM_FR2_enum2value_18[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_pdsch_256QAM_FR2_specs_18 = {
	asn_MAP_pdsch_256QAM_FR2_value2enum_18,	/* "tag" => N; sorted by tag */
	asn_MAP_pdsch_256QAM_FR2_enum2value_18,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_pdsch_256QAM_FR2_tags_18[] = {
	(ASN_TAG_CLASS_CONTEXT | (9 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_pdsch_256QAM_FR2_18 = {
	"pdsch-256QAM-FR2",
	"pdsch-256QAM-FR2",
	&asn_OP_NativeEnumerated,
	asn_DEF_pdsch_256QAM_FR2_tags_18,
	sizeof(asn_DEF_pdsch_256QAM_FR2_tags_18)
		/sizeof(asn_DEF_pdsch_256QAM_FR2_tags_18[0]) - 1, /* 1 */
	asn_DEF_pdsch_256QAM_FR2_tags_18,	/* Same as above */
	sizeof(asn_DEF_pdsch_256QAM_FR2_tags_18)
		/sizeof(asn_DEF_pdsch_256QAM_FR2_tags_18[0]), /* 2 */
	{ &asn_OER_type_pdsch_256QAM_FR2_constr_18, &asn_PER_type_pdsch_256QAM_FR2_constr_18, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_pdsch_256QAM_FR2_specs_18	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_pusch_256QAM_value2enum_20[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_pusch_256QAM_enum2value_20[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_pusch_256QAM_specs_20 = {
	asn_MAP_pusch_256QAM_value2enum_20,	/* "tag" => N; sorted by tag */
	asn_MAP_pusch_256QAM_enum2value_20,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_pusch_256QAM_tags_20[] = {
	(ASN_TAG_CLASS_CONTEXT | (10 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_pusch_256QAM_20 = {
	"pusch-256QAM",
	"pusch-256QAM",
	&asn_OP_NativeEnumerated,
	asn_DEF_pusch_256QAM_tags_20,
	sizeof(asn_DEF_pusch_256QAM_tags_20)
		/sizeof(asn_DEF_pusch_256QAM_tags_20[0]) - 1, /* 1 */
	asn_DEF_pusch_256QAM_tags_20,	/* Same as above */
	sizeof(asn_DEF_pusch_256QAM_tags_20)
		/sizeof(asn_DEF_pusch_256QAM_tags_20[0]), /* 2 */
	{ &asn_OER_type_pusch_256QAM_constr_20, &asn_PER_type_pusch_256QAM_constr_20, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_pusch_256QAM_specs_20	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_ue_PowerClass_value2enum_22[] = {
	{ 0,	3,	"pc1" },
	{ 1,	3,	"pc2" },
	{ 2,	3,	"pc3" },
	{ 3,	3,	"pc4" }
};
static const unsigned int asn_MAP_ue_PowerClass_enum2value_22[] = {
	0,	/* pc1(0) */
	1,	/* pc2(1) */
	2,	/* pc3(2) */
	3	/* pc4(3) */
};
static const asn_INTEGER_specifics_t asn_SPC_ue_PowerClass_specs_22 = {
	asn_MAP_ue_PowerClass_value2enum_22,	/* "tag" => N; sorted by tag */
	asn_MAP_ue_PowerClass_enum2value_22,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_ue_PowerClass_tags_22[] = {
	(ASN_TAG_CLASS_CONTEXT | (11 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_ue_PowerClass_22 = {
	"ue-PowerClass",
	"ue-PowerClass",
	&asn_OP_NativeEnumerated,
	asn_DEF_ue_PowerClass_tags_22,
	sizeof(asn_DEF_ue_PowerClass_tags_22)
		/sizeof(asn_DEF_ue_PowerClass_tags_22[0]) - 1, /* 1 */
	asn_DEF_ue_PowerClass_tags_22,	/* Same as above */
	sizeof(asn_DEF_ue_PowerClass_tags_22)
		/sizeof(asn_DEF_ue_PowerClass_tags_22[0]), /* 2 */
	{ &asn_OER_type_ue_PowerClass_constr_22, &asn_PER_type_ue_PowerClass_constr_22, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_ue_PowerClass_specs_22	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_rateMatchingLTE_CRS_value2enum_27[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_rateMatchingLTE_CRS_enum2value_27[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_rateMatchingLTE_CRS_specs_27 = {
	asn_MAP_rateMatchingLTE_CRS_value2enum_27,	/* "tag" => N; sorted by tag */
	asn_MAP_rateMatchingLTE_CRS_enum2value_27,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_rateMatchingLTE_CRS_tags_27[] = {
	(ASN_TAG_CLASS_CONTEXT | (12 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_rateMatchingLTE_CRS_27 = {
	"rateMatchingLTE-CRS",
	"rateMatchingLTE-CRS",
	&asn_OP_NativeEnumerated,
	asn_DEF_rateMatchingLTE_CRS_tags_27,
	sizeof(asn_DEF_rateMatchingLTE_CRS_tags_27)
		/sizeof(asn_DEF_rateMatchingLTE_CRS_tags_27[0]) - 1, /* 1 */
	asn_DEF_rateMatchingLTE_CRS_tags_27,	/* Same as above */
	sizeof(asn_DEF_rateMatchingLTE_CRS_tags_27)
		/sizeof(asn_DEF_rateMatchingLTE_CRS_tags_27[0]), /* 2 */
	{ &asn_OER_type_rateMatchingLTE_CRS_constr_27, &asn_PER_type_rateMatchingLTE_CRS_constr_27, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_rateMatchingLTE_CRS_specs_27	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_fr1_30[] = {
	{ ATF_POINTER, 3, offsetof(struct BandNR__channelBWs_DL__fr1, scs_15kHz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_15kHz_constr_31, &asn_PER_memb_scs_15kHz_constr_31,  memb_scs_15kHz_constraint_30 },
		0, 0, /* No default value */
		"scs-15kHz"
		},
	{ ATF_POINTER, 2, offsetof(struct BandNR__channelBWs_DL__fr1, scs_30kHz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_30kHz_constr_32, &asn_PER_memb_scs_30kHz_constr_32,  memb_scs_30kHz_constraint_30 },
		0, 0, /* No default value */
		"scs-30kHz"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR__channelBWs_DL__fr1, scs_60kHz),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_60kHz_constr_33, &asn_PER_memb_scs_60kHz_constr_33,  memb_scs_60kHz_constraint_30 },
		0, 0, /* No default value */
		"scs-60kHz"
		},
};
static const int asn_MAP_fr1_oms_30[] = { 0, 1, 2 };
static const ber_tlv_tag_t asn_DEF_fr1_tags_30[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_fr1_tag2el_30[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* scs-15kHz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* scs-30kHz */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* scs-60kHz */
};
static asn_SEQUENCE_specifics_t asn_SPC_fr1_specs_30 = {
	sizeof(struct BandNR__channelBWs_DL__fr1),
	offsetof(struct BandNR__channelBWs_DL__fr1, _asn_ctx),
	asn_MAP_fr1_tag2el_30,
	3,	/* Count of tags in the map */
	asn_MAP_fr1_oms_30,	/* Optional members */
	3, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_fr1_30 = {
	"fr1",
	"fr1",
	&asn_OP_SEQUENCE,
	asn_DEF_fr1_tags_30,
	sizeof(asn_DEF_fr1_tags_30)
		/sizeof(asn_DEF_fr1_tags_30[0]) - 1, /* 1 */
	asn_DEF_fr1_tags_30,	/* Same as above */
	sizeof(asn_DEF_fr1_tags_30)
		/sizeof(asn_DEF_fr1_tags_30[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_fr1_30,
	3,	/* Elements count */
	&asn_SPC_fr1_specs_30	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_fr2_34[] = {
	{ ATF_POINTER, 2, offsetof(struct BandNR__channelBWs_DL__fr2, scs_60kHz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_60kHz_constr_35, &asn_PER_memb_scs_60kHz_constr_35,  memb_scs_60kHz_constraint_34 },
		0, 0, /* No default value */
		"scs-60kHz"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR__channelBWs_DL__fr2, scs_120kHz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_120kHz_constr_36, &asn_PER_memb_scs_120kHz_constr_36,  memb_scs_120kHz_constraint_34 },
		0, 0, /* No default value */
		"scs-120kHz"
		},
};
static const int asn_MAP_fr2_oms_34[] = { 0, 1 };
static const ber_tlv_tag_t asn_DEF_fr2_tags_34[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_fr2_tag2el_34[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* scs-60kHz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* scs-120kHz */
};
static asn_SEQUENCE_specifics_t asn_SPC_fr2_specs_34 = {
	sizeof(struct BandNR__channelBWs_DL__fr2),
	offsetof(struct BandNR__channelBWs_DL__fr2, _asn_ctx),
	asn_MAP_fr2_tag2el_34,
	2,	/* Count of tags in the map */
	asn_MAP_fr2_oms_34,	/* Optional members */
	2, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_fr2_34 = {
	"fr2",
	"fr2",
	&asn_OP_SEQUENCE,
	asn_DEF_fr2_tags_34,
	sizeof(asn_DEF_fr2_tags_34)
		/sizeof(asn_DEF_fr2_tags_34[0]) - 1, /* 1 */
	asn_DEF_fr2_tags_34,	/* Same as above */
	sizeof(asn_DEF_fr2_tags_34)
		/sizeof(asn_DEF_fr2_tags_34[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_fr2_34,
	2,	/* Elements count */
	&asn_SPC_fr2_specs_34	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_channelBWs_DL_29[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__channelBWs_DL, choice.fr1),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		0,
		&asn_DEF_fr1_30,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"fr1"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__channelBWs_DL, choice.fr2),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		0,
		&asn_DEF_fr2_34,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"fr2"
		},
};
static const asn_TYPE_tag2member_t asn_MAP_channelBWs_DL_tag2el_29[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* fr1 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* fr2 */
};
static asn_CHOICE_specifics_t asn_SPC_channelBWs_DL_specs_29 = {
	sizeof(struct BandNR__channelBWs_DL),
	offsetof(struct BandNR__channelBWs_DL, _asn_ctx),
	offsetof(struct BandNR__channelBWs_DL, present),
	sizeof(((struct BandNR__channelBWs_DL *)0)->present),
	asn_MAP_channelBWs_DL_tag2el_29,
	2,	/* Count of tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_channelBWs_DL_29 = {
	"channelBWs-DL",
	"channelBWs-DL",
	&asn_OP_CHOICE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ &asn_OER_type_channelBWs_DL_constr_29, &asn_PER_type_channelBWs_DL_constr_29, CHOICE_constraint },
	asn_MBR_channelBWs_DL_29,
	2,	/* Elements count */
	&asn_SPC_channelBWs_DL_specs_29	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_fr1_38[] = {
	{ ATF_POINTER, 3, offsetof(struct BandNR__channelBWs_UL__fr1, scs_15kHz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_15kHz_constr_39, &asn_PER_memb_scs_15kHz_constr_39,  memb_scs_15kHz_constraint_38 },
		0, 0, /* No default value */
		"scs-15kHz"
		},
	{ ATF_POINTER, 2, offsetof(struct BandNR__channelBWs_UL__fr1, scs_30kHz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_30kHz_constr_40, &asn_PER_memb_scs_30kHz_constr_40,  memb_scs_30kHz_constraint_38 },
		0, 0, /* No default value */
		"scs-30kHz"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR__channelBWs_UL__fr1, scs_60kHz),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_60kHz_constr_41, &asn_PER_memb_scs_60kHz_constr_41,  memb_scs_60kHz_constraint_38 },
		0, 0, /* No default value */
		"scs-60kHz"
		},
};
static const int asn_MAP_fr1_oms_38[] = { 0, 1, 2 };
static const ber_tlv_tag_t asn_DEF_fr1_tags_38[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_fr1_tag2el_38[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* scs-15kHz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* scs-30kHz */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* scs-60kHz */
};
static asn_SEQUENCE_specifics_t asn_SPC_fr1_specs_38 = {
	sizeof(struct BandNR__channelBWs_UL__fr1),
	offsetof(struct BandNR__channelBWs_UL__fr1, _asn_ctx),
	asn_MAP_fr1_tag2el_38,
	3,	/* Count of tags in the map */
	asn_MAP_fr1_oms_38,	/* Optional members */
	3, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_fr1_38 = {
	"fr1",
	"fr1",
	&asn_OP_SEQUENCE,
	asn_DEF_fr1_tags_38,
	sizeof(asn_DEF_fr1_tags_38)
		/sizeof(asn_DEF_fr1_tags_38[0]) - 1, /* 1 */
	asn_DEF_fr1_tags_38,	/* Same as above */
	sizeof(asn_DEF_fr1_tags_38)
		/sizeof(asn_DEF_fr1_tags_38[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_fr1_38,
	3,	/* Elements count */
	&asn_SPC_fr1_specs_38	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_fr2_42[] = {
	{ ATF_POINTER, 2, offsetof(struct BandNR__channelBWs_UL__fr2, scs_60kHz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_60kHz_constr_43, &asn_PER_memb_scs_60kHz_constr_43,  memb_scs_60kHz_constraint_42 },
		0, 0, /* No default value */
		"scs-60kHz"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR__channelBWs_UL__fr2, scs_120kHz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_120kHz_constr_44, &asn_PER_memb_scs_120kHz_constr_44,  memb_scs_120kHz_constraint_42 },
		0, 0, /* No default value */
		"scs-120kHz"
		},
};
static const int asn_MAP_fr2_oms_42[] = { 0, 1 };
static const ber_tlv_tag_t asn_DEF_fr2_tags_42[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_fr2_tag2el_42[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* scs-60kHz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* scs-120kHz */
};
static asn_SEQUENCE_specifics_t asn_SPC_fr2_specs_42 = {
	sizeof(struct BandNR__channelBWs_UL__fr2),
	offsetof(struct BandNR__channelBWs_UL__fr2, _asn_ctx),
	asn_MAP_fr2_tag2el_42,
	2,	/* Count of tags in the map */
	asn_MAP_fr2_oms_42,	/* Optional members */
	2, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_fr2_42 = {
	"fr2",
	"fr2",
	&asn_OP_SEQUENCE,
	asn_DEF_fr2_tags_42,
	sizeof(asn_DEF_fr2_tags_42)
		/sizeof(asn_DEF_fr2_tags_42[0]) - 1, /* 1 */
	asn_DEF_fr2_tags_42,	/* Same as above */
	sizeof(asn_DEF_fr2_tags_42)
		/sizeof(asn_DEF_fr2_tags_42[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_fr2_42,
	2,	/* Elements count */
	&asn_SPC_fr2_specs_42	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_channelBWs_UL_37[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__channelBWs_UL, choice.fr1),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		0,
		&asn_DEF_fr1_38,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"fr1"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__channelBWs_UL, choice.fr2),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		0,
		&asn_DEF_fr2_42,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"fr2"
		},
};
static const asn_TYPE_tag2member_t asn_MAP_channelBWs_UL_tag2el_37[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* fr1 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* fr2 */
};
static asn_CHOICE_specifics_t asn_SPC_channelBWs_UL_specs_37 = {
	sizeof(struct BandNR__channelBWs_UL),
	offsetof(struct BandNR__channelBWs_UL, _asn_ctx),
	offsetof(struct BandNR__channelBWs_UL, present),
	sizeof(((struct BandNR__channelBWs_UL *)0)->present),
	asn_MAP_channelBWs_UL_tag2el_37,
	2,	/* Count of tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_channelBWs_UL_37 = {
	"channelBWs-UL",
	"channelBWs-UL",
	&asn_OP_CHOICE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ &asn_OER_type_channelBWs_UL_constr_37, &asn_PER_type_channelBWs_UL_constr_37, CHOICE_constraint },
	asn_MBR_channelBWs_UL_37,
	2,	/* Elements count */
	&asn_SPC_channelBWs_UL_specs_37	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_maxUplinkDutyCycle_PC2_FR1_value2enum_46[] = {
	{ 0,	3,	"n60" },
	{ 1,	3,	"n70" },
	{ 2,	3,	"n80" },
	{ 3,	3,	"n90" },
	{ 4,	4,	"n100" }
};
static const unsigned int asn_MAP_maxUplinkDutyCycle_PC2_FR1_enum2value_46[] = {
	4,	/* n100(4) */
	0,	/* n60(0) */
	1,	/* n70(1) */
	2,	/* n80(2) */
	3	/* n90(3) */
};
static const asn_INTEGER_specifics_t asn_SPC_maxUplinkDutyCycle_PC2_FR1_specs_46 = {
	asn_MAP_maxUplinkDutyCycle_PC2_FR1_value2enum_46,	/* "tag" => N; sorted by tag */
	asn_MAP_maxUplinkDutyCycle_PC2_FR1_enum2value_46,	/* N => "tag"; sorted by N */
	5,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_maxUplinkDutyCycle_PC2_FR1_tags_46[] = {
	(ASN_TAG_CLASS_CONTEXT | (15 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_maxUplinkDutyCycle_PC2_FR1_46 = {
	"maxUplinkDutyCycle-PC2-FR1",
	"maxUplinkDutyCycle-PC2-FR1",
	&asn_OP_NativeEnumerated,
	asn_DEF_maxUplinkDutyCycle_PC2_FR1_tags_46,
	sizeof(asn_DEF_maxUplinkDutyCycle_PC2_FR1_tags_46)
		/sizeof(asn_DEF_maxUplinkDutyCycle_PC2_FR1_tags_46[0]) - 1, /* 1 */
	asn_DEF_maxUplinkDutyCycle_PC2_FR1_tags_46,	/* Same as above */
	sizeof(asn_DEF_maxUplinkDutyCycle_PC2_FR1_tags_46)
		/sizeof(asn_DEF_maxUplinkDutyCycle_PC2_FR1_tags_46[0]), /* 2 */
	{ &asn_OER_type_maxUplinkDutyCycle_PC2_FR1_constr_46, &asn_PER_type_maxUplinkDutyCycle_PC2_FR1_constr_46, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_maxUplinkDutyCycle_PC2_FR1_specs_46	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_pucch_SpatialRelInfoMAC_CE_value2enum_52[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_pucch_SpatialRelInfoMAC_CE_enum2value_52[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_pucch_SpatialRelInfoMAC_CE_specs_52 = {
	asn_MAP_pucch_SpatialRelInfoMAC_CE_value2enum_52,	/* "tag" => N; sorted by tag */
	asn_MAP_pucch_SpatialRelInfoMAC_CE_enum2value_52,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_pucch_SpatialRelInfoMAC_CE_tags_52[] = {
	(ASN_TAG_CLASS_CONTEXT | (16 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_pucch_SpatialRelInfoMAC_CE_52 = {
	"pucch-SpatialRelInfoMAC-CE",
	"pucch-SpatialRelInfoMAC-CE",
	&asn_OP_NativeEnumerated,
	asn_DEF_pucch_SpatialRelInfoMAC_CE_tags_52,
	sizeof(asn_DEF_pucch_SpatialRelInfoMAC_CE_tags_52)
		/sizeof(asn_DEF_pucch_SpatialRelInfoMAC_CE_tags_52[0]) - 1, /* 1 */
	asn_DEF_pucch_SpatialRelInfoMAC_CE_tags_52,	/* Same as above */
	sizeof(asn_DEF_pucch_SpatialRelInfoMAC_CE_tags_52)
		/sizeof(asn_DEF_pucch_SpatialRelInfoMAC_CE_tags_52[0]), /* 2 */
	{ &asn_OER_type_pucch_SpatialRelInfoMAC_CE_constr_52, &asn_PER_type_pucch_SpatialRelInfoMAC_CE_constr_52, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_pucch_SpatialRelInfoMAC_CE_specs_52	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_powerBoosting_pi2BPSK_value2enum_54[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_powerBoosting_pi2BPSK_enum2value_54[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_powerBoosting_pi2BPSK_specs_54 = {
	asn_MAP_powerBoosting_pi2BPSK_value2enum_54,	/* "tag" => N; sorted by tag */
	asn_MAP_powerBoosting_pi2BPSK_enum2value_54,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_powerBoosting_pi2BPSK_tags_54[] = {
	(ASN_TAG_CLASS_CONTEXT | (17 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_powerBoosting_pi2BPSK_54 = {
	"powerBoosting-pi2BPSK",
	"powerBoosting-pi2BPSK",
	&asn_OP_NativeEnumerated,
	asn_DEF_powerBoosting_pi2BPSK_tags_54,
	sizeof(asn_DEF_powerBoosting_pi2BPSK_tags_54)
		/sizeof(asn_DEF_powerBoosting_pi2BPSK_tags_54[0]) - 1, /* 1 */
	asn_DEF_powerBoosting_pi2BPSK_tags_54,	/* Same as above */
	sizeof(asn_DEF_powerBoosting_pi2BPSK_tags_54)
		/sizeof(asn_DEF_powerBoosting_pi2BPSK_tags_54[0]), /* 2 */
	{ &asn_OER_type_powerBoosting_pi2BPSK_constr_54, &asn_PER_type_powerBoosting_pi2BPSK_constr_54, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_powerBoosting_pi2BPSK_specs_54	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_maxUplinkDutyCycle_FR2_value2enum_56[] = {
	{ 0,	3,	"n15" },
	{ 1,	3,	"n20" },
	{ 2,	3,	"n25" },
	{ 3,	3,	"n30" },
	{ 4,	3,	"n40" },
	{ 5,	3,	"n50" },
	{ 6,	3,	"n60" },
	{ 7,	3,	"n70" },
	{ 8,	3,	"n80" },
	{ 9,	3,	"n90" },
	{ 10,	4,	"n100" }
};
static const unsigned int asn_MAP_maxUplinkDutyCycle_FR2_enum2value_56[] = {
	10,	/* n100(10) */
	0,	/* n15(0) */
	1,	/* n20(1) */
	2,	/* n25(2) */
	3,	/* n30(3) */
	4,	/* n40(4) */
	5,	/* n50(5) */
	6,	/* n60(6) */
	7,	/* n70(7) */
	8,	/* n80(8) */
	9	/* n90(9) */
};
static const asn_INTEGER_specifics_t asn_SPC_maxUplinkDutyCycle_FR2_specs_56 = {
	asn_MAP_maxUplinkDutyCycle_FR2_value2enum_56,	/* "tag" => N; sorted by tag */
	asn_MAP_maxUplinkDutyCycle_FR2_enum2value_56,	/* N => "tag"; sorted by N */
	11,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_maxUplinkDutyCycle_FR2_tags_56[] = {
	(ASN_TAG_CLASS_CONTEXT | (18 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_maxUplinkDutyCycle_FR2_56 = {
	"maxUplinkDutyCycle-FR2",
	"maxUplinkDutyCycle-FR2",
	&asn_OP_NativeEnumerated,
	asn_DEF_maxUplinkDutyCycle_FR2_tags_56,
	sizeof(asn_DEF_maxUplinkDutyCycle_FR2_tags_56)
		/sizeof(asn_DEF_maxUplinkDutyCycle_FR2_tags_56[0]) - 1, /* 1 */
	asn_DEF_maxUplinkDutyCycle_FR2_tags_56,	/* Same as above */
	sizeof(asn_DEF_maxUplinkDutyCycle_FR2_tags_56)
		/sizeof(asn_DEF_maxUplinkDutyCycle_FR2_tags_56[0]), /* 2 */
	{ &asn_OER_type_maxUplinkDutyCycle_FR2_constr_56, &asn_PER_type_maxUplinkDutyCycle_FR2_constr_56, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_maxUplinkDutyCycle_FR2_specs_56	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_fr1_69[] = {
	{ ATF_POINTER, 3, offsetof(struct BandNR__channelBWs_DL_v1590__fr1, scs_15kHz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_15kHz_constr_70, &asn_PER_memb_scs_15kHz_constr_70,  memb_scs_15kHz_constraint_69 },
		0, 0, /* No default value */
		"scs-15kHz"
		},
	{ ATF_POINTER, 2, offsetof(struct BandNR__channelBWs_DL_v1590__fr1, scs_30kHz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_30kHz_constr_71, &asn_PER_memb_scs_30kHz_constr_71,  memb_scs_30kHz_constraint_69 },
		0, 0, /* No default value */
		"scs-30kHz"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR__channelBWs_DL_v1590__fr1, scs_60kHz),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_60kHz_constr_72, &asn_PER_memb_scs_60kHz_constr_72,  memb_scs_60kHz_constraint_69 },
		0, 0, /* No default value */
		"scs-60kHz"
		},
};
static const int asn_MAP_fr1_oms_69[] = { 0, 1, 2 };
static const ber_tlv_tag_t asn_DEF_fr1_tags_69[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_fr1_tag2el_69[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* scs-15kHz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* scs-30kHz */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* scs-60kHz */
};
static asn_SEQUENCE_specifics_t asn_SPC_fr1_specs_69 = {
	sizeof(struct BandNR__channelBWs_DL_v1590__fr1),
	offsetof(struct BandNR__channelBWs_DL_v1590__fr1, _asn_ctx),
	asn_MAP_fr1_tag2el_69,
	3,	/* Count of tags in the map */
	asn_MAP_fr1_oms_69,	/* Optional members */
	3, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_fr1_69 = {
	"fr1",
	"fr1",
	&asn_OP_SEQUENCE,
	asn_DEF_fr1_tags_69,
	sizeof(asn_DEF_fr1_tags_69)
		/sizeof(asn_DEF_fr1_tags_69[0]) - 1, /* 1 */
	asn_DEF_fr1_tags_69,	/* Same as above */
	sizeof(asn_DEF_fr1_tags_69)
		/sizeof(asn_DEF_fr1_tags_69[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_fr1_69,
	3,	/* Elements count */
	&asn_SPC_fr1_specs_69	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_fr2_73[] = {
	{ ATF_POINTER, 2, offsetof(struct BandNR__channelBWs_DL_v1590__fr2, scs_60kHz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_60kHz_constr_74, &asn_PER_memb_scs_60kHz_constr_74,  memb_scs_60kHz_constraint_73 },
		0, 0, /* No default value */
		"scs-60kHz"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR__channelBWs_DL_v1590__fr2, scs_120kHz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_120kHz_constr_75, &asn_PER_memb_scs_120kHz_constr_75,  memb_scs_120kHz_constraint_73 },
		0, 0, /* No default value */
		"scs-120kHz"
		},
};
static const int asn_MAP_fr2_oms_73[] = { 0, 1 };
static const ber_tlv_tag_t asn_DEF_fr2_tags_73[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_fr2_tag2el_73[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* scs-60kHz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* scs-120kHz */
};
static asn_SEQUENCE_specifics_t asn_SPC_fr2_specs_73 = {
	sizeof(struct BandNR__channelBWs_DL_v1590__fr2),
	offsetof(struct BandNR__channelBWs_DL_v1590__fr2, _asn_ctx),
	asn_MAP_fr2_tag2el_73,
	2,	/* Count of tags in the map */
	asn_MAP_fr2_oms_73,	/* Optional members */
	2, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_fr2_73 = {
	"fr2",
	"fr2",
	&asn_OP_SEQUENCE,
	asn_DEF_fr2_tags_73,
	sizeof(asn_DEF_fr2_tags_73)
		/sizeof(asn_DEF_fr2_tags_73[0]) - 1, /* 1 */
	asn_DEF_fr2_tags_73,	/* Same as above */
	sizeof(asn_DEF_fr2_tags_73)
		/sizeof(asn_DEF_fr2_tags_73[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_fr2_73,
	2,	/* Elements count */
	&asn_SPC_fr2_specs_73	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_channelBWs_DL_v1590_68[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__channelBWs_DL_v1590, choice.fr1),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		0,
		&asn_DEF_fr1_69,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"fr1"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__channelBWs_DL_v1590, choice.fr2),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		0,
		&asn_DEF_fr2_73,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"fr2"
		},
};
static const asn_TYPE_tag2member_t asn_MAP_channelBWs_DL_v1590_tag2el_68[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* fr1 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* fr2 */
};
static asn_CHOICE_specifics_t asn_SPC_channelBWs_DL_v1590_specs_68 = {
	sizeof(struct BandNR__channelBWs_DL_v1590),
	offsetof(struct BandNR__channelBWs_DL_v1590, _asn_ctx),
	offsetof(struct BandNR__channelBWs_DL_v1590, present),
	sizeof(((struct BandNR__channelBWs_DL_v1590 *)0)->present),
	asn_MAP_channelBWs_DL_v1590_tag2el_68,
	2,	/* Count of tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_channelBWs_DL_v1590_68 = {
	"channelBWs-DL-v1590",
	"channelBWs-DL-v1590",
	&asn_OP_CHOICE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ &asn_OER_type_channelBWs_DL_v1590_constr_68, &asn_PER_type_channelBWs_DL_v1590_constr_68, CHOICE_constraint },
	asn_MBR_channelBWs_DL_v1590_68,
	2,	/* Elements count */
	&asn_SPC_channelBWs_DL_v1590_specs_68	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_fr1_77[] = {
	{ ATF_POINTER, 3, offsetof(struct BandNR__channelBWs_UL_v1590__fr1, scs_15kHz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_15kHz_constr_78, &asn_PER_memb_scs_15kHz_constr_78,  memb_scs_15kHz_constraint_77 },
		0, 0, /* No default value */
		"scs-15kHz"
		},
	{ ATF_POINTER, 2, offsetof(struct BandNR__channelBWs_UL_v1590__fr1, scs_30kHz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_30kHz_constr_79, &asn_PER_memb_scs_30kHz_constr_79,  memb_scs_30kHz_constraint_77 },
		0, 0, /* No default value */
		"scs-30kHz"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR__channelBWs_UL_v1590__fr1, scs_60kHz),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_60kHz_constr_80, &asn_PER_memb_scs_60kHz_constr_80,  memb_scs_60kHz_constraint_77 },
		0, 0, /* No default value */
		"scs-60kHz"
		},
};
static const int asn_MAP_fr1_oms_77[] = { 0, 1, 2 };
static const ber_tlv_tag_t asn_DEF_fr1_tags_77[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_fr1_tag2el_77[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* scs-15kHz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* scs-30kHz */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* scs-60kHz */
};
static asn_SEQUENCE_specifics_t asn_SPC_fr1_specs_77 = {
	sizeof(struct BandNR__channelBWs_UL_v1590__fr1),
	offsetof(struct BandNR__channelBWs_UL_v1590__fr1, _asn_ctx),
	asn_MAP_fr1_tag2el_77,
	3,	/* Count of tags in the map */
	asn_MAP_fr1_oms_77,	/* Optional members */
	3, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_fr1_77 = {
	"fr1",
	"fr1",
	&asn_OP_SEQUENCE,
	asn_DEF_fr1_tags_77,
	sizeof(asn_DEF_fr1_tags_77)
		/sizeof(asn_DEF_fr1_tags_77[0]) - 1, /* 1 */
	asn_DEF_fr1_tags_77,	/* Same as above */
	sizeof(asn_DEF_fr1_tags_77)
		/sizeof(asn_DEF_fr1_tags_77[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_fr1_77,
	3,	/* Elements count */
	&asn_SPC_fr1_specs_77	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_fr2_81[] = {
	{ ATF_POINTER, 2, offsetof(struct BandNR__channelBWs_UL_v1590__fr2, scs_60kHz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_60kHz_constr_82, &asn_PER_memb_scs_60kHz_constr_82,  memb_scs_60kHz_constraint_81 },
		0, 0, /* No default value */
		"scs-60kHz"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR__channelBWs_UL_v1590__fr2, scs_120kHz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_scs_120kHz_constr_83, &asn_PER_memb_scs_120kHz_constr_83,  memb_scs_120kHz_constraint_81 },
		0, 0, /* No default value */
		"scs-120kHz"
		},
};
static const int asn_MAP_fr2_oms_81[] = { 0, 1 };
static const ber_tlv_tag_t asn_DEF_fr2_tags_81[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_fr2_tag2el_81[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* scs-60kHz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* scs-120kHz */
};
static asn_SEQUENCE_specifics_t asn_SPC_fr2_specs_81 = {
	sizeof(struct BandNR__channelBWs_UL_v1590__fr2),
	offsetof(struct BandNR__channelBWs_UL_v1590__fr2, _asn_ctx),
	asn_MAP_fr2_tag2el_81,
	2,	/* Count of tags in the map */
	asn_MAP_fr2_oms_81,	/* Optional members */
	2, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_fr2_81 = {
	"fr2",
	"fr2",
	&asn_OP_SEQUENCE,
	asn_DEF_fr2_tags_81,
	sizeof(asn_DEF_fr2_tags_81)
		/sizeof(asn_DEF_fr2_tags_81[0]) - 1, /* 1 */
	asn_DEF_fr2_tags_81,	/* Same as above */
	sizeof(asn_DEF_fr2_tags_81)
		/sizeof(asn_DEF_fr2_tags_81[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_fr2_81,
	2,	/* Elements count */
	&asn_SPC_fr2_specs_81	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_channelBWs_UL_v1590_76[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__channelBWs_UL_v1590, choice.fr1),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		0,
		&asn_DEF_fr1_77,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"fr1"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__channelBWs_UL_v1590, choice.fr2),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		0,
		&asn_DEF_fr2_81,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"fr2"
		},
};
static const asn_TYPE_tag2member_t asn_MAP_channelBWs_UL_v1590_tag2el_76[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* fr1 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* fr2 */
};
static asn_CHOICE_specifics_t asn_SPC_channelBWs_UL_v1590_specs_76 = {
	sizeof(struct BandNR__channelBWs_UL_v1590),
	offsetof(struct BandNR__channelBWs_UL_v1590, _asn_ctx),
	offsetof(struct BandNR__channelBWs_UL_v1590, present),
	sizeof(((struct BandNR__channelBWs_UL_v1590 *)0)->present),
	asn_MAP_channelBWs_UL_v1590_tag2el_76,
	2,	/* Count of tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_channelBWs_UL_v1590_76 = {
	"channelBWs-UL-v1590",
	"channelBWs-UL-v1590",
	&asn_OP_CHOICE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ &asn_OER_type_channelBWs_UL_v1590_constr_76, &asn_PER_type_channelBWs_UL_v1590_constr_76, CHOICE_constraint },
	asn_MBR_channelBWs_UL_v1590_76,
	2,	/* Elements count */
	&asn_SPC_channelBWs_UL_v1590_specs_76	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_cancelOverlappingPUSCH_r16_value2enum_86[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_cancelOverlappingPUSCH_r16_enum2value_86[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_cancelOverlappingPUSCH_r16_specs_86 = {
	asn_MAP_cancelOverlappingPUSCH_r16_value2enum_86,	/* "tag" => N; sorted by tag */
	asn_MAP_cancelOverlappingPUSCH_r16_enum2value_86,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_cancelOverlappingPUSCH_r16_tags_86[] = {
	(ASN_TAG_CLASS_CONTEXT | (23 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_cancelOverlappingPUSCH_r16_86 = {
	"cancelOverlappingPUSCH-r16",
	"cancelOverlappingPUSCH-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_cancelOverlappingPUSCH_r16_tags_86,
	sizeof(asn_DEF_cancelOverlappingPUSCH_r16_tags_86)
		/sizeof(asn_DEF_cancelOverlappingPUSCH_r16_tags_86[0]) - 1, /* 1 */
	asn_DEF_cancelOverlappingPUSCH_r16_tags_86,	/* Same as above */
	sizeof(asn_DEF_cancelOverlappingPUSCH_r16_tags_86)
		/sizeof(asn_DEF_cancelOverlappingPUSCH_r16_tags_86[0]), /* 2 */
	{ &asn_OER_type_cancelOverlappingPUSCH_r16_constr_86, &asn_PER_type_cancelOverlappingPUSCH_r16_constr_86, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_cancelOverlappingPUSCH_r16_specs_86	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_multipleRateMatchingEUTRA_CRS_r16_88[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__multipleRateMatchingEUTRA_CRS_r16, maxNumberPatterns_r16),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_NativeInteger,
		0,
		{ &asn_OER_memb_maxNumberPatterns_r16_constr_89, &asn_PER_memb_maxNumberPatterns_r16_constr_89,  memb_maxNumberPatterns_r16_constraint_88 },
		0, 0, /* No default value */
		"maxNumberPatterns-r16"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__multipleRateMatchingEUTRA_CRS_r16, maxNumberNon_OverlapPatterns_r16),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_NativeInteger,
		0,
		{ &asn_OER_memb_maxNumberNon_OverlapPatterns_r16_constr_90, &asn_PER_memb_maxNumberNon_OverlapPatterns_r16_constr_90,  memb_maxNumberNon_OverlapPatterns_r16_constraint_88 },
		0, 0, /* No default value */
		"maxNumberNon-OverlapPatterns-r16"
		},
};
static const ber_tlv_tag_t asn_DEF_multipleRateMatchingEUTRA_CRS_r16_tags_88[] = {
	(ASN_TAG_CLASS_CONTEXT | (24 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_multipleRateMatchingEUTRA_CRS_r16_tag2el_88[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* maxNumberPatterns-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* maxNumberNon-OverlapPatterns-r16 */
};
static asn_SEQUENCE_specifics_t asn_SPC_multipleRateMatchingEUTRA_CRS_r16_specs_88 = {
	sizeof(struct BandNR__multipleRateMatchingEUTRA_CRS_r16),
	offsetof(struct BandNR__multipleRateMatchingEUTRA_CRS_r16, _asn_ctx),
	asn_MAP_multipleRateMatchingEUTRA_CRS_r16_tag2el_88,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_multipleRateMatchingEUTRA_CRS_r16_88 = {
	"multipleRateMatchingEUTRA-CRS-r16",
	"multipleRateMatchingEUTRA-CRS-r16",
	&asn_OP_SEQUENCE,
	asn_DEF_multipleRateMatchingEUTRA_CRS_r16_tags_88,
	sizeof(asn_DEF_multipleRateMatchingEUTRA_CRS_r16_tags_88)
		/sizeof(asn_DEF_multipleRateMatchingEUTRA_CRS_r16_tags_88[0]) - 1, /* 1 */
	asn_DEF_multipleRateMatchingEUTRA_CRS_r16_tags_88,	/* Same as above */
	sizeof(asn_DEF_multipleRateMatchingEUTRA_CRS_r16_tags_88)
		/sizeof(asn_DEF_multipleRateMatchingEUTRA_CRS_r16_tags_88[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_multipleRateMatchingEUTRA_CRS_r16_88,
	2,	/* Elements count */
	&asn_SPC_multipleRateMatchingEUTRA_CRS_r16_specs_88	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_overlapRateMatchingEUTRA_CRS_r16_value2enum_91[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_overlapRateMatchingEUTRA_CRS_r16_enum2value_91[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_overlapRateMatchingEUTRA_CRS_r16_specs_91 = {
	asn_MAP_overlapRateMatchingEUTRA_CRS_r16_value2enum_91,	/* "tag" => N; sorted by tag */
	asn_MAP_overlapRateMatchingEUTRA_CRS_r16_enum2value_91,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_overlapRateMatchingEUTRA_CRS_r16_tags_91[] = {
	(ASN_TAG_CLASS_CONTEXT | (25 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_overlapRateMatchingEUTRA_CRS_r16_91 = {
	"overlapRateMatchingEUTRA-CRS-r16",
	"overlapRateMatchingEUTRA-CRS-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_overlapRateMatchingEUTRA_CRS_r16_tags_91,
	sizeof(asn_DEF_overlapRateMatchingEUTRA_CRS_r16_tags_91)
		/sizeof(asn_DEF_overlapRateMatchingEUTRA_CRS_r16_tags_91[0]) - 1, /* 1 */
	asn_DEF_overlapRateMatchingEUTRA_CRS_r16_tags_91,	/* Same as above */
	sizeof(asn_DEF_overlapRateMatchingEUTRA_CRS_r16_tags_91)
		/sizeof(asn_DEF_overlapRateMatchingEUTRA_CRS_r16_tags_91[0]), /* 2 */
	{ &asn_OER_type_overlapRateMatchingEUTRA_CRS_r16_constr_91, &asn_PER_type_overlapRateMatchingEUTRA_CRS_r16_constr_91, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_overlapRateMatchingEUTRA_CRS_r16_specs_91	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_pdsch_MappingTypeB_Alt_r16_value2enum_93[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_pdsch_MappingTypeB_Alt_r16_enum2value_93[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_pdsch_MappingTypeB_Alt_r16_specs_93 = {
	asn_MAP_pdsch_MappingTypeB_Alt_r16_value2enum_93,	/* "tag" => N; sorted by tag */
	asn_MAP_pdsch_MappingTypeB_Alt_r16_enum2value_93,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_pdsch_MappingTypeB_Alt_r16_tags_93[] = {
	(ASN_TAG_CLASS_CONTEXT | (26 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_pdsch_MappingTypeB_Alt_r16_93 = {
	"pdsch-MappingTypeB-Alt-r16",
	"pdsch-MappingTypeB-Alt-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_pdsch_MappingTypeB_Alt_r16_tags_93,
	sizeof(asn_DEF_pdsch_MappingTypeB_Alt_r16_tags_93)
		/sizeof(asn_DEF_pdsch_MappingTypeB_Alt_r16_tags_93[0]) - 1, /* 1 */
	asn_DEF_pdsch_MappingTypeB_Alt_r16_tags_93,	/* Same as above */
	sizeof(asn_DEF_pdsch_MappingTypeB_Alt_r16_tags_93)
		/sizeof(asn_DEF_pdsch_MappingTypeB_Alt_r16_tags_93[0]), /* 2 */
	{ &asn_OER_type_pdsch_MappingTypeB_Alt_r16_constr_93, &asn_PER_type_pdsch_MappingTypeB_Alt_r16_constr_93, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_pdsch_MappingTypeB_Alt_r16_specs_93	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_oneSlotPeriodicTRS_r16_value2enum_95[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_oneSlotPeriodicTRS_r16_enum2value_95[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_oneSlotPeriodicTRS_r16_specs_95 = {
	asn_MAP_oneSlotPeriodicTRS_r16_value2enum_95,	/* "tag" => N; sorted by tag */
	asn_MAP_oneSlotPeriodicTRS_r16_enum2value_95,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_oneSlotPeriodicTRS_r16_tags_95[] = {
	(ASN_TAG_CLASS_CONTEXT | (27 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_oneSlotPeriodicTRS_r16_95 = {
	"oneSlotPeriodicTRS-r16",
	"oneSlotPeriodicTRS-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_oneSlotPeriodicTRS_r16_tags_95,
	sizeof(asn_DEF_oneSlotPeriodicTRS_r16_tags_95)
		/sizeof(asn_DEF_oneSlotPeriodicTRS_r16_tags_95[0]) - 1, /* 1 */
	asn_DEF_oneSlotPeriodicTRS_r16_tags_95,	/* Same as above */
	sizeof(asn_DEF_oneSlotPeriodicTRS_r16_tags_95)
		/sizeof(asn_DEF_oneSlotPeriodicTRS_r16_tags_95[0]), /* 2 */
	{ &asn_OER_type_oneSlotPeriodicTRS_r16_constr_95, &asn_PER_type_oneSlotPeriodicTRS_r16_constr_95, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_oneSlotPeriodicTRS_r16_specs_95	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_simulSRS_MIMO_TransWithinBand_r16_value2enum_99[] = {
	{ 0,	2,	"n2" }
};
static const unsigned int asn_MAP_simulSRS_MIMO_TransWithinBand_r16_enum2value_99[] = {
	0	/* n2(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_simulSRS_MIMO_TransWithinBand_r16_specs_99 = {
	asn_MAP_simulSRS_MIMO_TransWithinBand_r16_value2enum_99,	/* "tag" => N; sorted by tag */
	asn_MAP_simulSRS_MIMO_TransWithinBand_r16_enum2value_99,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_simulSRS_MIMO_TransWithinBand_r16_tags_99[] = {
	(ASN_TAG_CLASS_CONTEXT | (30 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_simulSRS_MIMO_TransWithinBand_r16_99 = {
	"simulSRS-MIMO-TransWithinBand-r16",
	"simulSRS-MIMO-TransWithinBand-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_simulSRS_MIMO_TransWithinBand_r16_tags_99,
	sizeof(asn_DEF_simulSRS_MIMO_TransWithinBand_r16_tags_99)
		/sizeof(asn_DEF_simulSRS_MIMO_TransWithinBand_r16_tags_99[0]) - 1, /* 1 */
	asn_DEF_simulSRS_MIMO_TransWithinBand_r16_tags_99,	/* Same as above */
	sizeof(asn_DEF_simulSRS_MIMO_TransWithinBand_r16_tags_99)
		/sizeof(asn_DEF_simulSRS_MIMO_TransWithinBand_r16_tags_99[0]), /* 2 */
	{ &asn_OER_type_simulSRS_MIMO_TransWithinBand_r16_constr_99, &asn_PER_type_simulSRS_MIMO_TransWithinBand_r16_constr_99, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_simulSRS_MIMO_TransWithinBand_r16_specs_99	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_scs_15kHz_value2enum_103[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_scs_15kHz_enum2value_103[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_scs_15kHz_specs_103 = {
	asn_MAP_scs_15kHz_value2enum_103,	/* "tag" => N; sorted by tag */
	asn_MAP_scs_15kHz_enum2value_103,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_scs_15kHz_tags_103[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_scs_15kHz_103 = {
	"scs-15kHz",
	"scs-15kHz",
	&asn_OP_NativeEnumerated,
	asn_DEF_scs_15kHz_tags_103,
	sizeof(asn_DEF_scs_15kHz_tags_103)
		/sizeof(asn_DEF_scs_15kHz_tags_103[0]) - 1, /* 1 */
	asn_DEF_scs_15kHz_tags_103,	/* Same as above */
	sizeof(asn_DEF_scs_15kHz_tags_103)
		/sizeof(asn_DEF_scs_15kHz_tags_103[0]), /* 2 */
	{ &asn_OER_type_scs_15kHz_constr_103, &asn_PER_type_scs_15kHz_constr_103, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_scs_15kHz_specs_103	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_scs_30kHz_value2enum_105[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_scs_30kHz_enum2value_105[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_scs_30kHz_specs_105 = {
	asn_MAP_scs_30kHz_value2enum_105,	/* "tag" => N; sorted by tag */
	asn_MAP_scs_30kHz_enum2value_105,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_scs_30kHz_tags_105[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_scs_30kHz_105 = {
	"scs-30kHz",
	"scs-30kHz",
	&asn_OP_NativeEnumerated,
	asn_DEF_scs_30kHz_tags_105,
	sizeof(asn_DEF_scs_30kHz_tags_105)
		/sizeof(asn_DEF_scs_30kHz_tags_105[0]) - 1, /* 1 */
	asn_DEF_scs_30kHz_tags_105,	/* Same as above */
	sizeof(asn_DEF_scs_30kHz_tags_105)
		/sizeof(asn_DEF_scs_30kHz_tags_105[0]), /* 2 */
	{ &asn_OER_type_scs_30kHz_constr_105, &asn_PER_type_scs_30kHz_constr_105, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_scs_30kHz_specs_105	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_scs_60kHz_value2enum_107[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_scs_60kHz_enum2value_107[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_scs_60kHz_specs_107 = {
	asn_MAP_scs_60kHz_value2enum_107,	/* "tag" => N; sorted by tag */
	asn_MAP_scs_60kHz_enum2value_107,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_scs_60kHz_tags_107[] = {
	(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_scs_60kHz_107 = {
	"scs-60kHz",
	"scs-60kHz",
	&asn_OP_NativeEnumerated,
	asn_DEF_scs_60kHz_tags_107,
	sizeof(asn_DEF_scs_60kHz_tags_107)
		/sizeof(asn_DEF_scs_60kHz_tags_107[0]) - 1, /* 1 */
	asn_DEF_scs_60kHz_tags_107,	/* Same as above */
	sizeof(asn_DEF_scs_60kHz_tags_107)
		/sizeof(asn_DEF_scs_60kHz_tags_107[0]), /* 2 */
	{ &asn_OER_type_scs_60kHz_constr_107, &asn_PER_type_scs_60kHz_constr_107, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_scs_60kHz_specs_107	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_fr1_100mhz_102[] = {
	{ ATF_POINTER, 3, offsetof(struct BandNR__channelBW_DL_IAB_r16__fr1_100mhz, scs_15kHz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_scs_15kHz_103,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"scs-15kHz"
		},
	{ ATF_POINTER, 2, offsetof(struct BandNR__channelBW_DL_IAB_r16__fr1_100mhz, scs_30kHz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_scs_30kHz_105,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"scs-30kHz"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR__channelBW_DL_IAB_r16__fr1_100mhz, scs_60kHz),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_scs_60kHz_107,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"scs-60kHz"
		},
};
static const int asn_MAP_fr1_100mhz_oms_102[] = { 0, 1, 2 };
static const ber_tlv_tag_t asn_DEF_fr1_100mhz_tags_102[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_fr1_100mhz_tag2el_102[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* scs-15kHz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* scs-30kHz */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* scs-60kHz */
};
static asn_SEQUENCE_specifics_t asn_SPC_fr1_100mhz_specs_102 = {
	sizeof(struct BandNR__channelBW_DL_IAB_r16__fr1_100mhz),
	offsetof(struct BandNR__channelBW_DL_IAB_r16__fr1_100mhz, _asn_ctx),
	asn_MAP_fr1_100mhz_tag2el_102,
	3,	/* Count of tags in the map */
	asn_MAP_fr1_100mhz_oms_102,	/* Optional members */
	3, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_fr1_100mhz_102 = {
	"fr1-100mhz",
	"fr1-100mhz",
	&asn_OP_SEQUENCE,
	asn_DEF_fr1_100mhz_tags_102,
	sizeof(asn_DEF_fr1_100mhz_tags_102)
		/sizeof(asn_DEF_fr1_100mhz_tags_102[0]) - 1, /* 1 */
	asn_DEF_fr1_100mhz_tags_102,	/* Same as above */
	sizeof(asn_DEF_fr1_100mhz_tags_102)
		/sizeof(asn_DEF_fr1_100mhz_tags_102[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_fr1_100mhz_102,
	3,	/* Elements count */
	&asn_SPC_fr1_100mhz_specs_102	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_scs_60kHz_value2enum_110[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_scs_60kHz_enum2value_110[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_scs_60kHz_specs_110 = {
	asn_MAP_scs_60kHz_value2enum_110,	/* "tag" => N; sorted by tag */
	asn_MAP_scs_60kHz_enum2value_110,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_scs_60kHz_tags_110[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_scs_60kHz_110 = {
	"scs-60kHz",
	"scs-60kHz",
	&asn_OP_NativeEnumerated,
	asn_DEF_scs_60kHz_tags_110,
	sizeof(asn_DEF_scs_60kHz_tags_110)
		/sizeof(asn_DEF_scs_60kHz_tags_110[0]) - 1, /* 1 */
	asn_DEF_scs_60kHz_tags_110,	/* Same as above */
	sizeof(asn_DEF_scs_60kHz_tags_110)
		/sizeof(asn_DEF_scs_60kHz_tags_110[0]), /* 2 */
	{ &asn_OER_type_scs_60kHz_constr_110, &asn_PER_type_scs_60kHz_constr_110, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_scs_60kHz_specs_110	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_scs_120kHz_value2enum_112[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_scs_120kHz_enum2value_112[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_scs_120kHz_specs_112 = {
	asn_MAP_scs_120kHz_value2enum_112,	/* "tag" => N; sorted by tag */
	asn_MAP_scs_120kHz_enum2value_112,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_scs_120kHz_tags_112[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_scs_120kHz_112 = {
	"scs-120kHz",
	"scs-120kHz",
	&asn_OP_NativeEnumerated,
	asn_DEF_scs_120kHz_tags_112,
	sizeof(asn_DEF_scs_120kHz_tags_112)
		/sizeof(asn_DEF_scs_120kHz_tags_112[0]) - 1, /* 1 */
	asn_DEF_scs_120kHz_tags_112,	/* Same as above */
	sizeof(asn_DEF_scs_120kHz_tags_112)
		/sizeof(asn_DEF_scs_120kHz_tags_112[0]), /* 2 */
	{ &asn_OER_type_scs_120kHz_constr_112, &asn_PER_type_scs_120kHz_constr_112, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_scs_120kHz_specs_112	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_fr2_200mhz_109[] = {
	{ ATF_POINTER, 2, offsetof(struct BandNR__channelBW_DL_IAB_r16__fr2_200mhz, scs_60kHz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_scs_60kHz_110,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"scs-60kHz"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR__channelBW_DL_IAB_r16__fr2_200mhz, scs_120kHz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_scs_120kHz_112,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"scs-120kHz"
		},
};
static const int asn_MAP_fr2_200mhz_oms_109[] = { 0, 1 };
static const ber_tlv_tag_t asn_DEF_fr2_200mhz_tags_109[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_fr2_200mhz_tag2el_109[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* scs-60kHz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* scs-120kHz */
};
static asn_SEQUENCE_specifics_t asn_SPC_fr2_200mhz_specs_109 = {
	sizeof(struct BandNR__channelBW_DL_IAB_r16__fr2_200mhz),
	offsetof(struct BandNR__channelBW_DL_IAB_r16__fr2_200mhz, _asn_ctx),
	asn_MAP_fr2_200mhz_tag2el_109,
	2,	/* Count of tags in the map */
	asn_MAP_fr2_200mhz_oms_109,	/* Optional members */
	2, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_fr2_200mhz_109 = {
	"fr2-200mhz",
	"fr2-200mhz",
	&asn_OP_SEQUENCE,
	asn_DEF_fr2_200mhz_tags_109,
	sizeof(asn_DEF_fr2_200mhz_tags_109)
		/sizeof(asn_DEF_fr2_200mhz_tags_109[0]) - 1, /* 1 */
	asn_DEF_fr2_200mhz_tags_109,	/* Same as above */
	sizeof(asn_DEF_fr2_200mhz_tags_109)
		/sizeof(asn_DEF_fr2_200mhz_tags_109[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_fr2_200mhz_109,
	2,	/* Elements count */
	&asn_SPC_fr2_200mhz_specs_109	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_channelBW_DL_IAB_r16_101[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__channelBW_DL_IAB_r16, choice.fr1_100mhz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		0,
		&asn_DEF_fr1_100mhz_102,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"fr1-100mhz"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__channelBW_DL_IAB_r16, choice.fr2_200mhz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		0,
		&asn_DEF_fr2_200mhz_109,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"fr2-200mhz"
		},
};
static const asn_TYPE_tag2member_t asn_MAP_channelBW_DL_IAB_r16_tag2el_101[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* fr1-100mhz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* fr2-200mhz */
};
static asn_CHOICE_specifics_t asn_SPC_channelBW_DL_IAB_r16_specs_101 = {
	sizeof(struct BandNR__channelBW_DL_IAB_r16),
	offsetof(struct BandNR__channelBW_DL_IAB_r16, _asn_ctx),
	offsetof(struct BandNR__channelBW_DL_IAB_r16, present),
	sizeof(((struct BandNR__channelBW_DL_IAB_r16 *)0)->present),
	asn_MAP_channelBW_DL_IAB_r16_tag2el_101,
	2,	/* Count of tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_channelBW_DL_IAB_r16_101 = {
	"channelBW-DL-IAB-r16",
	"channelBW-DL-IAB-r16",
	&asn_OP_CHOICE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ &asn_OER_type_channelBW_DL_IAB_r16_constr_101, &asn_PER_type_channelBW_DL_IAB_r16_constr_101, CHOICE_constraint },
	asn_MBR_channelBW_DL_IAB_r16_101,
	2,	/* Elements count */
	&asn_SPC_channelBW_DL_IAB_r16_specs_101	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_scs_15kHz_value2enum_116[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_scs_15kHz_enum2value_116[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_scs_15kHz_specs_116 = {
	asn_MAP_scs_15kHz_value2enum_116,	/* "tag" => N; sorted by tag */
	asn_MAP_scs_15kHz_enum2value_116,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_scs_15kHz_tags_116[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_scs_15kHz_116 = {
	"scs-15kHz",
	"scs-15kHz",
	&asn_OP_NativeEnumerated,
	asn_DEF_scs_15kHz_tags_116,
	sizeof(asn_DEF_scs_15kHz_tags_116)
		/sizeof(asn_DEF_scs_15kHz_tags_116[0]) - 1, /* 1 */
	asn_DEF_scs_15kHz_tags_116,	/* Same as above */
	sizeof(asn_DEF_scs_15kHz_tags_116)
		/sizeof(asn_DEF_scs_15kHz_tags_116[0]), /* 2 */
	{ &asn_OER_type_scs_15kHz_constr_116, &asn_PER_type_scs_15kHz_constr_116, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_scs_15kHz_specs_116	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_scs_30kHz_value2enum_118[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_scs_30kHz_enum2value_118[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_scs_30kHz_specs_118 = {
	asn_MAP_scs_30kHz_value2enum_118,	/* "tag" => N; sorted by tag */
	asn_MAP_scs_30kHz_enum2value_118,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_scs_30kHz_tags_118[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_scs_30kHz_118 = {
	"scs-30kHz",
	"scs-30kHz",
	&asn_OP_NativeEnumerated,
	asn_DEF_scs_30kHz_tags_118,
	sizeof(asn_DEF_scs_30kHz_tags_118)
		/sizeof(asn_DEF_scs_30kHz_tags_118[0]) - 1, /* 1 */
	asn_DEF_scs_30kHz_tags_118,	/* Same as above */
	sizeof(asn_DEF_scs_30kHz_tags_118)
		/sizeof(asn_DEF_scs_30kHz_tags_118[0]), /* 2 */
	{ &asn_OER_type_scs_30kHz_constr_118, &asn_PER_type_scs_30kHz_constr_118, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_scs_30kHz_specs_118	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_scs_60kHz_value2enum_120[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_scs_60kHz_enum2value_120[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_scs_60kHz_specs_120 = {
	asn_MAP_scs_60kHz_value2enum_120,	/* "tag" => N; sorted by tag */
	asn_MAP_scs_60kHz_enum2value_120,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_scs_60kHz_tags_120[] = {
	(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_scs_60kHz_120 = {
	"scs-60kHz",
	"scs-60kHz",
	&asn_OP_NativeEnumerated,
	asn_DEF_scs_60kHz_tags_120,
	sizeof(asn_DEF_scs_60kHz_tags_120)
		/sizeof(asn_DEF_scs_60kHz_tags_120[0]) - 1, /* 1 */
	asn_DEF_scs_60kHz_tags_120,	/* Same as above */
	sizeof(asn_DEF_scs_60kHz_tags_120)
		/sizeof(asn_DEF_scs_60kHz_tags_120[0]), /* 2 */
	{ &asn_OER_type_scs_60kHz_constr_120, &asn_PER_type_scs_60kHz_constr_120, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_scs_60kHz_specs_120	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_fr1_100mhz_115[] = {
	{ ATF_POINTER, 3, offsetof(struct BandNR__channelBW_UL_IAB_r16__fr1_100mhz, scs_15kHz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_scs_15kHz_116,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"scs-15kHz"
		},
	{ ATF_POINTER, 2, offsetof(struct BandNR__channelBW_UL_IAB_r16__fr1_100mhz, scs_30kHz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_scs_30kHz_118,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"scs-30kHz"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR__channelBW_UL_IAB_r16__fr1_100mhz, scs_60kHz),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_scs_60kHz_120,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"scs-60kHz"
		},
};
static const int asn_MAP_fr1_100mhz_oms_115[] = { 0, 1, 2 };
static const ber_tlv_tag_t asn_DEF_fr1_100mhz_tags_115[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_fr1_100mhz_tag2el_115[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* scs-15kHz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* scs-30kHz */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* scs-60kHz */
};
static asn_SEQUENCE_specifics_t asn_SPC_fr1_100mhz_specs_115 = {
	sizeof(struct BandNR__channelBW_UL_IAB_r16__fr1_100mhz),
	offsetof(struct BandNR__channelBW_UL_IAB_r16__fr1_100mhz, _asn_ctx),
	asn_MAP_fr1_100mhz_tag2el_115,
	3,	/* Count of tags in the map */
	asn_MAP_fr1_100mhz_oms_115,	/* Optional members */
	3, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_fr1_100mhz_115 = {
	"fr1-100mhz",
	"fr1-100mhz",
	&asn_OP_SEQUENCE,
	asn_DEF_fr1_100mhz_tags_115,
	sizeof(asn_DEF_fr1_100mhz_tags_115)
		/sizeof(asn_DEF_fr1_100mhz_tags_115[0]) - 1, /* 1 */
	asn_DEF_fr1_100mhz_tags_115,	/* Same as above */
	sizeof(asn_DEF_fr1_100mhz_tags_115)
		/sizeof(asn_DEF_fr1_100mhz_tags_115[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_fr1_100mhz_115,
	3,	/* Elements count */
	&asn_SPC_fr1_100mhz_specs_115	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_scs_60kHz_value2enum_123[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_scs_60kHz_enum2value_123[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_scs_60kHz_specs_123 = {
	asn_MAP_scs_60kHz_value2enum_123,	/* "tag" => N; sorted by tag */
	asn_MAP_scs_60kHz_enum2value_123,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_scs_60kHz_tags_123[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_scs_60kHz_123 = {
	"scs-60kHz",
	"scs-60kHz",
	&asn_OP_NativeEnumerated,
	asn_DEF_scs_60kHz_tags_123,
	sizeof(asn_DEF_scs_60kHz_tags_123)
		/sizeof(asn_DEF_scs_60kHz_tags_123[0]) - 1, /* 1 */
	asn_DEF_scs_60kHz_tags_123,	/* Same as above */
	sizeof(asn_DEF_scs_60kHz_tags_123)
		/sizeof(asn_DEF_scs_60kHz_tags_123[0]), /* 2 */
	{ &asn_OER_type_scs_60kHz_constr_123, &asn_PER_type_scs_60kHz_constr_123, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_scs_60kHz_specs_123	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_scs_120kHz_value2enum_125[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_scs_120kHz_enum2value_125[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_scs_120kHz_specs_125 = {
	asn_MAP_scs_120kHz_value2enum_125,	/* "tag" => N; sorted by tag */
	asn_MAP_scs_120kHz_enum2value_125,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_scs_120kHz_tags_125[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_scs_120kHz_125 = {
	"scs-120kHz",
	"scs-120kHz",
	&asn_OP_NativeEnumerated,
	asn_DEF_scs_120kHz_tags_125,
	sizeof(asn_DEF_scs_120kHz_tags_125)
		/sizeof(asn_DEF_scs_120kHz_tags_125[0]) - 1, /* 1 */
	asn_DEF_scs_120kHz_tags_125,	/* Same as above */
	sizeof(asn_DEF_scs_120kHz_tags_125)
		/sizeof(asn_DEF_scs_120kHz_tags_125[0]), /* 2 */
	{ &asn_OER_type_scs_120kHz_constr_125, &asn_PER_type_scs_120kHz_constr_125, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_scs_120kHz_specs_125	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_fr2_200mhz_122[] = {
	{ ATF_POINTER, 2, offsetof(struct BandNR__channelBW_UL_IAB_r16__fr2_200mhz, scs_60kHz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_scs_60kHz_123,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"scs-60kHz"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR__channelBW_UL_IAB_r16__fr2_200mhz, scs_120kHz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_scs_120kHz_125,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"scs-120kHz"
		},
};
static const int asn_MAP_fr2_200mhz_oms_122[] = { 0, 1 };
static const ber_tlv_tag_t asn_DEF_fr2_200mhz_tags_122[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_fr2_200mhz_tag2el_122[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* scs-60kHz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* scs-120kHz */
};
static asn_SEQUENCE_specifics_t asn_SPC_fr2_200mhz_specs_122 = {
	sizeof(struct BandNR__channelBW_UL_IAB_r16__fr2_200mhz),
	offsetof(struct BandNR__channelBW_UL_IAB_r16__fr2_200mhz, _asn_ctx),
	asn_MAP_fr2_200mhz_tag2el_122,
	2,	/* Count of tags in the map */
	asn_MAP_fr2_200mhz_oms_122,	/* Optional members */
	2, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_fr2_200mhz_122 = {
	"fr2-200mhz",
	"fr2-200mhz",
	&asn_OP_SEQUENCE,
	asn_DEF_fr2_200mhz_tags_122,
	sizeof(asn_DEF_fr2_200mhz_tags_122)
		/sizeof(asn_DEF_fr2_200mhz_tags_122[0]) - 1, /* 1 */
	asn_DEF_fr2_200mhz_tags_122,	/* Same as above */
	sizeof(asn_DEF_fr2_200mhz_tags_122)
		/sizeof(asn_DEF_fr2_200mhz_tags_122[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_fr2_200mhz_122,
	2,	/* Elements count */
	&asn_SPC_fr2_200mhz_specs_122	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_channelBW_UL_IAB_r16_114[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__channelBW_UL_IAB_r16, choice.fr1_100mhz),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		0,
		&asn_DEF_fr1_100mhz_115,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"fr1-100mhz"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__channelBW_UL_IAB_r16, choice.fr2_200mhz),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		0,
		&asn_DEF_fr2_200mhz_122,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"fr2-200mhz"
		},
};
static const asn_TYPE_tag2member_t asn_MAP_channelBW_UL_IAB_r16_tag2el_114[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* fr1-100mhz */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* fr2-200mhz */
};
static asn_CHOICE_specifics_t asn_SPC_channelBW_UL_IAB_r16_specs_114 = {
	sizeof(struct BandNR__channelBW_UL_IAB_r16),
	offsetof(struct BandNR__channelBW_UL_IAB_r16, _asn_ctx),
	offsetof(struct BandNR__channelBW_UL_IAB_r16, present),
	sizeof(((struct BandNR__channelBW_UL_IAB_r16 *)0)->present),
	asn_MAP_channelBW_UL_IAB_r16_tag2el_114,
	2,	/* Count of tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_channelBW_UL_IAB_r16_114 = {
	"channelBW-UL-IAB-r16",
	"channelBW-UL-IAB-r16",
	&asn_OP_CHOICE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ &asn_OER_type_channelBW_UL_IAB_r16_constr_114, &asn_PER_type_channelBW_UL_IAB_r16_constr_114, CHOICE_constraint },
	asn_MBR_channelBW_UL_IAB_r16_114,
	2,	/* Elements count */
	&asn_SPC_channelBW_UL_IAB_r16_specs_114	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_rasterShift7dot5_IAB_r16_value2enum_127[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_rasterShift7dot5_IAB_r16_enum2value_127[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_rasterShift7dot5_IAB_r16_specs_127 = {
	asn_MAP_rasterShift7dot5_IAB_r16_value2enum_127,	/* "tag" => N; sorted by tag */
	asn_MAP_rasterShift7dot5_IAB_r16_enum2value_127,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_rasterShift7dot5_IAB_r16_tags_127[] = {
	(ASN_TAG_CLASS_CONTEXT | (33 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_rasterShift7dot5_IAB_r16_127 = {
	"rasterShift7dot5-IAB-r16",
	"rasterShift7dot5-IAB-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_rasterShift7dot5_IAB_r16_tags_127,
	sizeof(asn_DEF_rasterShift7dot5_IAB_r16_tags_127)
		/sizeof(asn_DEF_rasterShift7dot5_IAB_r16_tags_127[0]) - 1, /* 1 */
	asn_DEF_rasterShift7dot5_IAB_r16_tags_127,	/* Same as above */
	sizeof(asn_DEF_rasterShift7dot5_IAB_r16_tags_127)
		/sizeof(asn_DEF_rasterShift7dot5_IAB_r16_tags_127[0]), /* 2 */
	{ &asn_OER_type_rasterShift7dot5_IAB_r16_constr_127, &asn_PER_type_rasterShift7dot5_IAB_r16_constr_127, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_rasterShift7dot5_IAB_r16_specs_127	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_ue_PowerClass_v1610_value2enum_129[] = {
	{ 0,	7,	"pc1dot5" }
};
static const unsigned int asn_MAP_ue_PowerClass_v1610_enum2value_129[] = {
	0	/* pc1dot5(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_ue_PowerClass_v1610_specs_129 = {
	asn_MAP_ue_PowerClass_v1610_value2enum_129,	/* "tag" => N; sorted by tag */
	asn_MAP_ue_PowerClass_v1610_enum2value_129,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_ue_PowerClass_v1610_tags_129[] = {
	(ASN_TAG_CLASS_CONTEXT | (34 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_ue_PowerClass_v1610_129 = {
	"ue-PowerClass-v1610",
	"ue-PowerClass-v1610",
	&asn_OP_NativeEnumerated,
	asn_DEF_ue_PowerClass_v1610_tags_129,
	sizeof(asn_DEF_ue_PowerClass_v1610_tags_129)
		/sizeof(asn_DEF_ue_PowerClass_v1610_tags_129[0]) - 1, /* 1 */
	asn_DEF_ue_PowerClass_v1610_tags_129,	/* Same as above */
	sizeof(asn_DEF_ue_PowerClass_v1610_tags_129)
		/sizeof(asn_DEF_ue_PowerClass_v1610_tags_129[0]), /* 2 */
	{ &asn_OER_type_ue_PowerClass_v1610_constr_129, &asn_PER_type_ue_PowerClass_v1610_constr_129, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_ue_PowerClass_v1610_specs_129	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_condHandover_r16_value2enum_131[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_condHandover_r16_enum2value_131[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_condHandover_r16_specs_131 = {
	asn_MAP_condHandover_r16_value2enum_131,	/* "tag" => N; sorted by tag */
	asn_MAP_condHandover_r16_enum2value_131,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_condHandover_r16_tags_131[] = {
	(ASN_TAG_CLASS_CONTEXT | (35 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_condHandover_r16_131 = {
	"condHandover-r16",
	"condHandover-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_condHandover_r16_tags_131,
	sizeof(asn_DEF_condHandover_r16_tags_131)
		/sizeof(asn_DEF_condHandover_r16_tags_131[0]) - 1, /* 1 */
	asn_DEF_condHandover_r16_tags_131,	/* Same as above */
	sizeof(asn_DEF_condHandover_r16_tags_131)
		/sizeof(asn_DEF_condHandover_r16_tags_131[0]), /* 2 */
	{ &asn_OER_type_condHandover_r16_constr_131, &asn_PER_type_condHandover_r16_constr_131, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_condHandover_r16_specs_131	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_condHandoverFailure_r16_value2enum_133[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_condHandoverFailure_r16_enum2value_133[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_condHandoverFailure_r16_specs_133 = {
	asn_MAP_condHandoverFailure_r16_value2enum_133,	/* "tag" => N; sorted by tag */
	asn_MAP_condHandoverFailure_r16_enum2value_133,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_condHandoverFailure_r16_tags_133[] = {
	(ASN_TAG_CLASS_CONTEXT | (36 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_condHandoverFailure_r16_133 = {
	"condHandoverFailure-r16",
	"condHandoverFailure-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_condHandoverFailure_r16_tags_133,
	sizeof(asn_DEF_condHandoverFailure_r16_tags_133)
		/sizeof(asn_DEF_condHandoverFailure_r16_tags_133[0]) - 1, /* 1 */
	asn_DEF_condHandoverFailure_r16_tags_133,	/* Same as above */
	sizeof(asn_DEF_condHandoverFailure_r16_tags_133)
		/sizeof(asn_DEF_condHandoverFailure_r16_tags_133[0]), /* 2 */
	{ &asn_OER_type_condHandoverFailure_r16_constr_133, &asn_PER_type_condHandoverFailure_r16_constr_133, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_condHandoverFailure_r16_specs_133	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_condHandoverTwoTriggerEvents_r16_value2enum_135[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_condHandoverTwoTriggerEvents_r16_enum2value_135[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_condHandoverTwoTriggerEvents_r16_specs_135 = {
	asn_MAP_condHandoverTwoTriggerEvents_r16_value2enum_135,	/* "tag" => N; sorted by tag */
	asn_MAP_condHandoverTwoTriggerEvents_r16_enum2value_135,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_condHandoverTwoTriggerEvents_r16_tags_135[] = {
	(ASN_TAG_CLASS_CONTEXT | (37 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_condHandoverTwoTriggerEvents_r16_135 = {
	"condHandoverTwoTriggerEvents-r16",
	"condHandoverTwoTriggerEvents-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_condHandoverTwoTriggerEvents_r16_tags_135,
	sizeof(asn_DEF_condHandoverTwoTriggerEvents_r16_tags_135)
		/sizeof(asn_DEF_condHandoverTwoTriggerEvents_r16_tags_135[0]) - 1, /* 1 */
	asn_DEF_condHandoverTwoTriggerEvents_r16_tags_135,	/* Same as above */
	sizeof(asn_DEF_condHandoverTwoTriggerEvents_r16_tags_135)
		/sizeof(asn_DEF_condHandoverTwoTriggerEvents_r16_tags_135[0]), /* 2 */
	{ &asn_OER_type_condHandoverTwoTriggerEvents_r16_constr_135, &asn_PER_type_condHandoverTwoTriggerEvents_r16_constr_135, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_condHandoverTwoTriggerEvents_r16_specs_135	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_condPSCellChange_r16_value2enum_137[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_condPSCellChange_r16_enum2value_137[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_condPSCellChange_r16_specs_137 = {
	asn_MAP_condPSCellChange_r16_value2enum_137,	/* "tag" => N; sorted by tag */
	asn_MAP_condPSCellChange_r16_enum2value_137,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_condPSCellChange_r16_tags_137[] = {
	(ASN_TAG_CLASS_CONTEXT | (38 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_condPSCellChange_r16_137 = {
	"condPSCellChange-r16",
	"condPSCellChange-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_condPSCellChange_r16_tags_137,
	sizeof(asn_DEF_condPSCellChange_r16_tags_137)
		/sizeof(asn_DEF_condPSCellChange_r16_tags_137[0]) - 1, /* 1 */
	asn_DEF_condPSCellChange_r16_tags_137,	/* Same as above */
	sizeof(asn_DEF_condPSCellChange_r16_tags_137)
		/sizeof(asn_DEF_condPSCellChange_r16_tags_137[0]), /* 2 */
	{ &asn_OER_type_condPSCellChange_r16_constr_137, &asn_PER_type_condPSCellChange_r16_constr_137, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_condPSCellChange_r16_specs_137	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_condPSCellChangeTwoTriggerEvents_r16_value2enum_139[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_condPSCellChangeTwoTriggerEvents_r16_enum2value_139[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_condPSCellChangeTwoTriggerEvents_r16_specs_139 = {
	asn_MAP_condPSCellChangeTwoTriggerEvents_r16_value2enum_139,	/* "tag" => N; sorted by tag */
	asn_MAP_condPSCellChangeTwoTriggerEvents_r16_enum2value_139,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_condPSCellChangeTwoTriggerEvents_r16_tags_139[] = {
	(ASN_TAG_CLASS_CONTEXT | (39 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_condPSCellChangeTwoTriggerEvents_r16_139 = {
	"condPSCellChangeTwoTriggerEvents-r16",
	"condPSCellChangeTwoTriggerEvents-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_condPSCellChangeTwoTriggerEvents_r16_tags_139,
	sizeof(asn_DEF_condPSCellChangeTwoTriggerEvents_r16_tags_139)
		/sizeof(asn_DEF_condPSCellChangeTwoTriggerEvents_r16_tags_139[0]) - 1, /* 1 */
	asn_DEF_condPSCellChangeTwoTriggerEvents_r16_tags_139,	/* Same as above */
	sizeof(asn_DEF_condPSCellChangeTwoTriggerEvents_r16_tags_139)
		/sizeof(asn_DEF_condPSCellChangeTwoTriggerEvents_r16_tags_139[0]), /* 2 */
	{ &asn_OER_type_condPSCellChangeTwoTriggerEvents_r16_constr_139, &asn_PER_type_condPSCellChangeTwoTriggerEvents_r16_constr_139, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_condPSCellChangeTwoTriggerEvents_r16_specs_139	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_mpr_PowerBoost_FR2_r16_value2enum_141[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_mpr_PowerBoost_FR2_r16_enum2value_141[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_mpr_PowerBoost_FR2_r16_specs_141 = {
	asn_MAP_mpr_PowerBoost_FR2_r16_value2enum_141,	/* "tag" => N; sorted by tag */
	asn_MAP_mpr_PowerBoost_FR2_r16_enum2value_141,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_mpr_PowerBoost_FR2_r16_tags_141[] = {
	(ASN_TAG_CLASS_CONTEXT | (40 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_mpr_PowerBoost_FR2_r16_141 = {
	"mpr-PowerBoost-FR2-r16",
	"mpr-PowerBoost-FR2-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_mpr_PowerBoost_FR2_r16_tags_141,
	sizeof(asn_DEF_mpr_PowerBoost_FR2_r16_tags_141)
		/sizeof(asn_DEF_mpr_PowerBoost_FR2_r16_tags_141[0]) - 1, /* 1 */
	asn_DEF_mpr_PowerBoost_FR2_r16_tags_141,	/* Same as above */
	sizeof(asn_DEF_mpr_PowerBoost_FR2_r16_tags_141)
		/sizeof(asn_DEF_mpr_PowerBoost_FR2_r16_tags_141[0]), /* 2 */
	{ &asn_OER_type_mpr_PowerBoost_FR2_r16_constr_141, &asn_PER_type_mpr_PowerBoost_FR2_r16_constr_141, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_mpr_PowerBoost_FR2_r16_specs_141	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_maxNumberConfigsPerBWP_r16_value2enum_144[] = {
	{ 0,	2,	"n1" },
	{ 1,	2,	"n2" },
	{ 2,	2,	"n4" },
	{ 3,	2,	"n8" },
	{ 4,	3,	"n12" }
};
static const unsigned int asn_MAP_maxNumberConfigsPerBWP_r16_enum2value_144[] = {
	0,	/* n1(0) */
	4,	/* n12(4) */
	1,	/* n2(1) */
	2,	/* n4(2) */
	3	/* n8(3) */
};
static const asn_INTEGER_specifics_t asn_SPC_maxNumberConfigsPerBWP_r16_specs_144 = {
	asn_MAP_maxNumberConfigsPerBWP_r16_value2enum_144,	/* "tag" => N; sorted by tag */
	asn_MAP_maxNumberConfigsPerBWP_r16_enum2value_144,	/* N => "tag"; sorted by N */
	5,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_maxNumberConfigsPerBWP_r16_tags_144[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_maxNumberConfigsPerBWP_r16_144 = {
	"maxNumberConfigsPerBWP-r16",
	"maxNumberConfigsPerBWP-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_maxNumberConfigsPerBWP_r16_tags_144,
	sizeof(asn_DEF_maxNumberConfigsPerBWP_r16_tags_144)
		/sizeof(asn_DEF_maxNumberConfigsPerBWP_r16_tags_144[0]) - 1, /* 1 */
	asn_DEF_maxNumberConfigsPerBWP_r16_tags_144,	/* Same as above */
	sizeof(asn_DEF_maxNumberConfigsPerBWP_r16_tags_144)
		/sizeof(asn_DEF_maxNumberConfigsPerBWP_r16_tags_144[0]), /* 2 */
	{ &asn_OER_type_maxNumberConfigsPerBWP_r16_constr_144, &asn_PER_type_maxNumberConfigsPerBWP_r16_constr_144, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_maxNumberConfigsPerBWP_r16_specs_144	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_activeConfiguredGrant_r16_143[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__activeConfiguredGrant_r16, maxNumberConfigsPerBWP_r16),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_maxNumberConfigsPerBWP_r16_144,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"maxNumberConfigsPerBWP-r16"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__activeConfiguredGrant_r16, maxNumberConfigsAllCC_r16),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_NativeInteger,
		0,
		{ &asn_OER_memb_maxNumberConfigsAllCC_r16_constr_150, &asn_PER_memb_maxNumberConfigsAllCC_r16_constr_150,  memb_maxNumberConfigsAllCC_r16_constraint_143 },
		0, 0, /* No default value */
		"maxNumberConfigsAllCC-r16"
		},
};
static const ber_tlv_tag_t asn_DEF_activeConfiguredGrant_r16_tags_143[] = {
	(ASN_TAG_CLASS_CONTEXT | (41 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_activeConfiguredGrant_r16_tag2el_143[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* maxNumberConfigsPerBWP-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* maxNumberConfigsAllCC-r16 */
};
static asn_SEQUENCE_specifics_t asn_SPC_activeConfiguredGrant_r16_specs_143 = {
	sizeof(struct BandNR__activeConfiguredGrant_r16),
	offsetof(struct BandNR__activeConfiguredGrant_r16, _asn_ctx),
	asn_MAP_activeConfiguredGrant_r16_tag2el_143,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_activeConfiguredGrant_r16_143 = {
	"activeConfiguredGrant-r16",
	"activeConfiguredGrant-r16",
	&asn_OP_SEQUENCE,
	asn_DEF_activeConfiguredGrant_r16_tags_143,
	sizeof(asn_DEF_activeConfiguredGrant_r16_tags_143)
		/sizeof(asn_DEF_activeConfiguredGrant_r16_tags_143[0]) - 1, /* 1 */
	asn_DEF_activeConfiguredGrant_r16_tags_143,	/* Same as above */
	sizeof(asn_DEF_activeConfiguredGrant_r16_tags_143)
		/sizeof(asn_DEF_activeConfiguredGrant_r16_tags_143[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_activeConfiguredGrant_r16_143,
	2,	/* Elements count */
	&asn_SPC_activeConfiguredGrant_r16_specs_143	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_jointReleaseConfiguredGrantType2_r16_value2enum_151[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_jointReleaseConfiguredGrantType2_r16_enum2value_151[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_jointReleaseConfiguredGrantType2_r16_specs_151 = {
	asn_MAP_jointReleaseConfiguredGrantType2_r16_value2enum_151,	/* "tag" => N; sorted by tag */
	asn_MAP_jointReleaseConfiguredGrantType2_r16_enum2value_151,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_jointReleaseConfiguredGrantType2_r16_tags_151[] = {
	(ASN_TAG_CLASS_CONTEXT | (42 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_jointReleaseConfiguredGrantType2_r16_151 = {
	"jointReleaseConfiguredGrantType2-r16",
	"jointReleaseConfiguredGrantType2-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_jointReleaseConfiguredGrantType2_r16_tags_151,
	sizeof(asn_DEF_jointReleaseConfiguredGrantType2_r16_tags_151)
		/sizeof(asn_DEF_jointReleaseConfiguredGrantType2_r16_tags_151[0]) - 1, /* 1 */
	asn_DEF_jointReleaseConfiguredGrantType2_r16_tags_151,	/* Same as above */
	sizeof(asn_DEF_jointReleaseConfiguredGrantType2_r16_tags_151)
		/sizeof(asn_DEF_jointReleaseConfiguredGrantType2_r16_tags_151[0]), /* 2 */
	{ &asn_OER_type_jointReleaseConfiguredGrantType2_r16_constr_151, &asn_PER_type_jointReleaseConfiguredGrantType2_r16_constr_151, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_jointReleaseConfiguredGrantType2_r16_specs_151	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_sps_r16_153[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__sps_r16, maxNumberConfigsPerBWP_r16),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_NativeInteger,
		0,
		{ &asn_OER_memb_maxNumberConfigsPerBWP_r16_constr_154, &asn_PER_memb_maxNumberConfigsPerBWP_r16_constr_154,  memb_maxNumberConfigsPerBWP_r16_constraint_153 },
		0, 0, /* No default value */
		"maxNumberConfigsPerBWP-r16"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR__sps_r16, maxNumberConfigsAllCC_r16),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_NativeInteger,
		0,
		{ &asn_OER_memb_maxNumberConfigsAllCC_r16_constr_155, &asn_PER_memb_maxNumberConfigsAllCC_r16_constr_155,  memb_maxNumberConfigsAllCC_r16_constraint_153 },
		0, 0, /* No default value */
		"maxNumberConfigsAllCC-r16"
		},
};
static const ber_tlv_tag_t asn_DEF_sps_r16_tags_153[] = {
	(ASN_TAG_CLASS_CONTEXT | (43 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_sps_r16_tag2el_153[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* maxNumberConfigsPerBWP-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* maxNumberConfigsAllCC-r16 */
};
static asn_SEQUENCE_specifics_t asn_SPC_sps_r16_specs_153 = {
	sizeof(struct BandNR__sps_r16),
	offsetof(struct BandNR__sps_r16, _asn_ctx),
	asn_MAP_sps_r16_tag2el_153,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_sps_r16_153 = {
	"sps-r16",
	"sps-r16",
	&asn_OP_SEQUENCE,
	asn_DEF_sps_r16_tags_153,
	sizeof(asn_DEF_sps_r16_tags_153)
		/sizeof(asn_DEF_sps_r16_tags_153[0]) - 1, /* 1 */
	asn_DEF_sps_r16_tags_153,	/* Same as above */
	sizeof(asn_DEF_sps_r16_tags_153)
		/sizeof(asn_DEF_sps_r16_tags_153[0]), /* 2 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_sps_r16_153,
	2,	/* Elements count */
	&asn_SPC_sps_r16_specs_153	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_jointReleaseSPS_r16_value2enum_156[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_jointReleaseSPS_r16_enum2value_156[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_jointReleaseSPS_r16_specs_156 = {
	asn_MAP_jointReleaseSPS_r16_value2enum_156,	/* "tag" => N; sorted by tag */
	asn_MAP_jointReleaseSPS_r16_enum2value_156,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_jointReleaseSPS_r16_tags_156[] = {
	(ASN_TAG_CLASS_CONTEXT | (44 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_jointReleaseSPS_r16_156 = {
	"jointReleaseSPS-r16",
	"jointReleaseSPS-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_jointReleaseSPS_r16_tags_156,
	sizeof(asn_DEF_jointReleaseSPS_r16_tags_156)
		/sizeof(asn_DEF_jointReleaseSPS_r16_tags_156[0]) - 1, /* 1 */
	asn_DEF_jointReleaseSPS_r16_tags_156,	/* Same as above */
	sizeof(asn_DEF_jointReleaseSPS_r16_tags_156)
		/sizeof(asn_DEF_jointReleaseSPS_r16_tags_156[0]), /* 2 */
	{ &asn_OER_type_jointReleaseSPS_r16_constr_156, &asn_PER_type_jointReleaseSPS_r16_constr_156, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_jointReleaseSPS_r16_specs_156	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_simulSRS_TransWithinBand_r16_value2enum_158[] = {
	{ 0,	2,	"n2" }
};
static const unsigned int asn_MAP_simulSRS_TransWithinBand_r16_enum2value_158[] = {
	0	/* n2(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_simulSRS_TransWithinBand_r16_specs_158 = {
	asn_MAP_simulSRS_TransWithinBand_r16_value2enum_158,	/* "tag" => N; sorted by tag */
	asn_MAP_simulSRS_TransWithinBand_r16_enum2value_158,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_simulSRS_TransWithinBand_r16_tags_158[] = {
	(ASN_TAG_CLASS_CONTEXT | (45 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_simulSRS_TransWithinBand_r16_158 = {
	"simulSRS-TransWithinBand-r16",
	"simulSRS-TransWithinBand-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_simulSRS_TransWithinBand_r16_tags_158,
	sizeof(asn_DEF_simulSRS_TransWithinBand_r16_tags_158)
		/sizeof(asn_DEF_simulSRS_TransWithinBand_r16_tags_158[0]) - 1, /* 1 */
	asn_DEF_simulSRS_TransWithinBand_r16_tags_158,	/* Same as above */
	sizeof(asn_DEF_simulSRS_TransWithinBand_r16_tags_158)
		/sizeof(asn_DEF_simulSRS_TransWithinBand_r16_tags_158[0]), /* 2 */
	{ &asn_OER_type_simulSRS_TransWithinBand_r16_constr_158, &asn_PER_type_simulSRS_TransWithinBand_r16_constr_158, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_simulSRS_TransWithinBand_r16_specs_158	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_trs_AdditionalBandwidth_r16_value2enum_160[] = {
	{ 0,	14,	"trs-AddBW-Set1" },
	{ 1,	14,	"trs-AddBW-Set2" }
};
static const unsigned int asn_MAP_trs_AdditionalBandwidth_r16_enum2value_160[] = {
	0,	/* trs-AddBW-Set1(0) */
	1	/* trs-AddBW-Set2(1) */
};
static const asn_INTEGER_specifics_t asn_SPC_trs_AdditionalBandwidth_r16_specs_160 = {
	asn_MAP_trs_AdditionalBandwidth_r16_value2enum_160,	/* "tag" => N; sorted by tag */
	asn_MAP_trs_AdditionalBandwidth_r16_enum2value_160,	/* N => "tag"; sorted by N */
	2,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_trs_AdditionalBandwidth_r16_tags_160[] = {
	(ASN_TAG_CLASS_CONTEXT | (46 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_trs_AdditionalBandwidth_r16_160 = {
	"trs-AdditionalBandwidth-r16",
	"trs-AdditionalBandwidth-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_trs_AdditionalBandwidth_r16_tags_160,
	sizeof(asn_DEF_trs_AdditionalBandwidth_r16_tags_160)
		/sizeof(asn_DEF_trs_AdditionalBandwidth_r16_tags_160[0]) - 1, /* 1 */
	asn_DEF_trs_AdditionalBandwidth_r16_tags_160,	/* Same as above */
	sizeof(asn_DEF_trs_AdditionalBandwidth_r16_tags_160)
		/sizeof(asn_DEF_trs_AdditionalBandwidth_r16_tags_160[0]), /* 2 */
	{ &asn_OER_type_trs_AdditionalBandwidth_r16_constr_160, &asn_PER_type_trs_AdditionalBandwidth_r16_constr_160, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_trs_AdditionalBandwidth_r16_specs_160	/* Additional specs */
};

static const asn_INTEGER_enum_map_t asn_MAP_handoverIntraF_IAB_r16_value2enum_163[] = {
	{ 0,	9,	"supported" }
};
static const unsigned int asn_MAP_handoverIntraF_IAB_r16_enum2value_163[] = {
	0	/* supported(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_handoverIntraF_IAB_r16_specs_163 = {
	asn_MAP_handoverIntraF_IAB_r16_value2enum_163,	/* "tag" => N; sorted by tag */
	asn_MAP_handoverIntraF_IAB_r16_enum2value_163,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_handoverIntraF_IAB_r16_tags_163[] = {
	(ASN_TAG_CLASS_CONTEXT | (47 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_handoverIntraF_IAB_r16_163 = {
	"handoverIntraF-IAB-r16",
	"handoverIntraF-IAB-r16",
	&asn_OP_NativeEnumerated,
	asn_DEF_handoverIntraF_IAB_r16_tags_163,
	sizeof(asn_DEF_handoverIntraF_IAB_r16_tags_163)
		/sizeof(asn_DEF_handoverIntraF_IAB_r16_tags_163[0]) - 1, /* 1 */
	asn_DEF_handoverIntraF_IAB_r16_tags_163,	/* Same as above */
	sizeof(asn_DEF_handoverIntraF_IAB_r16_tags_163)
		/sizeof(asn_DEF_handoverIntraF_IAB_r16_tags_163[0]), /* 2 */
	{ &asn_OER_type_handoverIntraF_IAB_r16_constr_163, &asn_PER_type_handoverIntraF_IAB_r16_constr_163, NativeEnumerated_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_handoverIntraF_IAB_r16_specs_163	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_BandNR_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct BandNR, bandNR),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_FreqBandIndicatorNR,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"bandNR"
		},
	{ ATF_POINTER, 47, offsetof(struct BandNR, modifiedMPR_Behaviour),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_modifiedMPR_Behaviour_constr_3, &asn_PER_memb_modifiedMPR_Behaviour_constr_3,  memb_modifiedMPR_Behaviour_constraint_1 },
		0, 0, /* No default value */
		"modifiedMPR-Behaviour"
		},
	{ ATF_POINTER, 46, offsetof(struct BandNR, mimo_ParametersPerBand),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_MIMO_ParametersPerBand,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"mimo-ParametersPerBand"
		},
	{ ATF_POINTER, 45, offsetof(struct BandNR, extendedCP),
		(ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_extendedCP_5,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"extendedCP"
		},
	{ ATF_POINTER, 44, offsetof(struct BandNR, multipleTCI),
		(ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_multipleTCI_7,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"multipleTCI"
		},
	{ ATF_POINTER, 43, offsetof(struct BandNR, bwp_WithoutRestriction),
		(ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_bwp_WithoutRestriction_9,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"bwp-WithoutRestriction"
		},
	{ ATF_POINTER, 42, offsetof(struct BandNR, bwp_SameNumerology),
		(ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_bwp_SameNumerology_11,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"bwp-SameNumerology"
		},
	{ ATF_POINTER, 41, offsetof(struct BandNR, bwp_DiffNumerology),
		(ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_bwp_DiffNumerology_14,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"bwp-DiffNumerology"
		},
	{ ATF_POINTER, 40, offsetof(struct BandNR, crossCarrierScheduling_SameSCS),
		(ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_crossCarrierScheduling_SameSCS_16,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"crossCarrierScheduling-SameSCS"
		},
	{ ATF_POINTER, 39, offsetof(struct BandNR, pdsch_256QAM_FR2),
		(ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_pdsch_256QAM_FR2_18,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"pdsch-256QAM-FR2"
		},
	{ ATF_POINTER, 38, offsetof(struct BandNR, pusch_256QAM),
		(ASN_TAG_CLASS_CONTEXT | (10 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_pusch_256QAM_20,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"pusch-256QAM"
		},
	{ ATF_POINTER, 37, offsetof(struct BandNR, ue_PowerClass),
		(ASN_TAG_CLASS_CONTEXT | (11 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ue_PowerClass_22,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"ue-PowerClass"
		},
	{ ATF_POINTER, 36, offsetof(struct BandNR, rateMatchingLTE_CRS),
		(ASN_TAG_CLASS_CONTEXT | (12 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_rateMatchingLTE_CRS_27,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"rateMatchingLTE-CRS"
		},
	{ ATF_POINTER, 35, offsetof(struct BandNR, channelBWs_DL),
		(ASN_TAG_CLASS_CONTEXT | (13 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_channelBWs_DL_29,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"channelBWs-DL"
		},
	{ ATF_POINTER, 34, offsetof(struct BandNR, channelBWs_UL),
		(ASN_TAG_CLASS_CONTEXT | (14 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_channelBWs_UL_37,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"channelBWs-UL"
		},
	{ ATF_POINTER, 33, offsetof(struct BandNR, maxUplinkDutyCycle_PC2_FR1),
		(ASN_TAG_CLASS_CONTEXT | (15 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_maxUplinkDutyCycle_PC2_FR1_46,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"maxUplinkDutyCycle-PC2-FR1"
		},
	{ ATF_POINTER, 32, offsetof(struct BandNR, pucch_SpatialRelInfoMAC_CE),
		(ASN_TAG_CLASS_CONTEXT | (16 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_pucch_SpatialRelInfoMAC_CE_52,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"pucch-SpatialRelInfoMAC-CE"
		},
	{ ATF_POINTER, 31, offsetof(struct BandNR, powerBoosting_pi2BPSK),
		(ASN_TAG_CLASS_CONTEXT | (17 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_powerBoosting_pi2BPSK_54,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"powerBoosting-pi2BPSK"
		},
	{ ATF_POINTER, 30, offsetof(struct BandNR, maxUplinkDutyCycle_FR2),
		(ASN_TAG_CLASS_CONTEXT | (18 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_maxUplinkDutyCycle_FR2_56,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"maxUplinkDutyCycle-FR2"
		},
	{ ATF_POINTER, 29, offsetof(struct BandNR, channelBWs_DL_v1590),
		(ASN_TAG_CLASS_CONTEXT | (19 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_channelBWs_DL_v1590_68,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"channelBWs-DL-v1590"
		},
	{ ATF_POINTER, 28, offsetof(struct BandNR, channelBWs_UL_v1590),
		(ASN_TAG_CLASS_CONTEXT | (20 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_channelBWs_UL_v1590_76,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"channelBWs-UL-v1590"
		},
	{ ATF_POINTER, 27, offsetof(struct BandNR, asymmetricBandwidthCombinationSet),
		(ASN_TAG_CLASS_CONTEXT | (21 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BIT_STRING,
		0,
		{ &asn_OER_memb_asymmetricBandwidthCombinationSet_constr_84, &asn_PER_memb_asymmetricBandwidthCombinationSet_constr_84,  memb_asymmetricBandwidthCombinationSet_constraint_1 },
		0, 0, /* No default value */
		"asymmetricBandwidthCombinationSet"
		},
	{ ATF_POINTER, 26, offsetof(struct BandNR, sharedSpectrumChAccessParamsPerBand_r16),
		(ASN_TAG_CLASS_CONTEXT | (22 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_SharedSpectrumChAccessParamsPerBand_r16,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"sharedSpectrumChAccessParamsPerBand-r16"
		},
	{ ATF_POINTER, 25, offsetof(struct BandNR, cancelOverlappingPUSCH_r16),
		(ASN_TAG_CLASS_CONTEXT | (23 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_cancelOverlappingPUSCH_r16_86,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"cancelOverlappingPUSCH-r16"
		},
	{ ATF_POINTER, 24, offsetof(struct BandNR, multipleRateMatchingEUTRA_CRS_r16),
		(ASN_TAG_CLASS_CONTEXT | (24 << 2)),
		0,
		&asn_DEF_multipleRateMatchingEUTRA_CRS_r16_88,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"multipleRateMatchingEUTRA-CRS-r16"
		},
	{ ATF_POINTER, 23, offsetof(struct BandNR, overlapRateMatchingEUTRA_CRS_r16),
		(ASN_TAG_CLASS_CONTEXT | (25 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_overlapRateMatchingEUTRA_CRS_r16_91,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"overlapRateMatchingEUTRA-CRS-r16"
		},
	{ ATF_POINTER, 22, offsetof(struct BandNR, pdsch_MappingTypeB_Alt_r16),
		(ASN_TAG_CLASS_CONTEXT | (26 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_pdsch_MappingTypeB_Alt_r16_93,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"pdsch-MappingTypeB-Alt-r16"
		},
	{ ATF_POINTER, 21, offsetof(struct BandNR, oneSlotPeriodicTRS_r16),
		(ASN_TAG_CLASS_CONTEXT | (27 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_oneSlotPeriodicTRS_r16_95,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"oneSlotPeriodicTRS-r16"
		},
	{ ATF_POINTER, 20, offsetof(struct BandNR, olpc_SRS_Pos_r16),
		(ASN_TAG_CLASS_CONTEXT | (28 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_OLPC_SRS_Pos_r16,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"olpc-SRS-Pos-r16"
		},
	{ ATF_POINTER, 19, offsetof(struct BandNR, spatialRelationsSRS_Pos_r16),
		(ASN_TAG_CLASS_CONTEXT | (29 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_SpatialRelationsSRS_Pos_r16,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"spatialRelationsSRS-Pos-r16"
		},
	{ ATF_POINTER, 18, offsetof(struct BandNR, simulSRS_MIMO_TransWithinBand_r16),
		(ASN_TAG_CLASS_CONTEXT | (30 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_simulSRS_MIMO_TransWithinBand_r16_99,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"simulSRS-MIMO-TransWithinBand-r16"
		},
	{ ATF_POINTER, 17, offsetof(struct BandNR, channelBW_DL_IAB_r16),
		(ASN_TAG_CLASS_CONTEXT | (31 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_channelBW_DL_IAB_r16_101,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"channelBW-DL-IAB-r16"
		},
	{ ATF_POINTER, 16, offsetof(struct BandNR, channelBW_UL_IAB_r16),
		(ASN_TAG_CLASS_CONTEXT | (32 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_channelBW_UL_IAB_r16_114,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"channelBW-UL-IAB-r16"
		},
	{ ATF_POINTER, 15, offsetof(struct BandNR, rasterShift7dot5_IAB_r16),
		(ASN_TAG_CLASS_CONTEXT | (33 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_rasterShift7dot5_IAB_r16_127,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"rasterShift7dot5-IAB-r16"
		},
	{ ATF_POINTER, 14, offsetof(struct BandNR, ue_PowerClass_v1610),
		(ASN_TAG_CLASS_CONTEXT | (34 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ue_PowerClass_v1610_129,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"ue-PowerClass-v1610"
		},
	{ ATF_POINTER, 13, offsetof(struct BandNR, condHandover_r16),
		(ASN_TAG_CLASS_CONTEXT | (35 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_condHandover_r16_131,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"condHandover-r16"
		},
	{ ATF_POINTER, 12, offsetof(struct BandNR, condHandoverFailure_r16),
		(ASN_TAG_CLASS_CONTEXT | (36 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_condHandoverFailure_r16_133,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"condHandoverFailure-r16"
		},
	{ ATF_POINTER, 11, offsetof(struct BandNR, condHandoverTwoTriggerEvents_r16),
		(ASN_TAG_CLASS_CONTEXT | (37 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_condHandoverTwoTriggerEvents_r16_135,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"condHandoverTwoTriggerEvents-r16"
		},
	{ ATF_POINTER, 10, offsetof(struct BandNR, condPSCellChange_r16),
		(ASN_TAG_CLASS_CONTEXT | (38 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_condPSCellChange_r16_137,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"condPSCellChange-r16"
		},
	{ ATF_POINTER, 9, offsetof(struct BandNR, condPSCellChangeTwoTriggerEvents_r16),
		(ASN_TAG_CLASS_CONTEXT | (39 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_condPSCellChangeTwoTriggerEvents_r16_139,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"condPSCellChangeTwoTriggerEvents-r16"
		},
	{ ATF_POINTER, 8, offsetof(struct BandNR, mpr_PowerBoost_FR2_r16),
		(ASN_TAG_CLASS_CONTEXT | (40 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_mpr_PowerBoost_FR2_r16_141,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"mpr-PowerBoost-FR2-r16"
		},
	{ ATF_POINTER, 7, offsetof(struct BandNR, activeConfiguredGrant_r16),
		(ASN_TAG_CLASS_CONTEXT | (41 << 2)),
		0,
		&asn_DEF_activeConfiguredGrant_r16_143,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"activeConfiguredGrant-r16"
		},
	{ ATF_POINTER, 6, offsetof(struct BandNR, jointReleaseConfiguredGrantType2_r16),
		(ASN_TAG_CLASS_CONTEXT | (42 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_jointReleaseConfiguredGrantType2_r16_151,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"jointReleaseConfiguredGrantType2-r16"
		},
	{ ATF_POINTER, 5, offsetof(struct BandNR, sps_r16),
		(ASN_TAG_CLASS_CONTEXT | (43 << 2)),
		0,
		&asn_DEF_sps_r16_153,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"sps-r16"
		},
	{ ATF_POINTER, 4, offsetof(struct BandNR, jointReleaseSPS_r16),
		(ASN_TAG_CLASS_CONTEXT | (44 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_jointReleaseSPS_r16_156,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"jointReleaseSPS-r16"
		},
	{ ATF_POINTER, 3, offsetof(struct BandNR, simulSRS_TransWithinBand_r16),
		(ASN_TAG_CLASS_CONTEXT | (45 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_simulSRS_TransWithinBand_r16_158,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"simulSRS-TransWithinBand-r16"
		},
	{ ATF_POINTER, 2, offsetof(struct BandNR, trs_AdditionalBandwidth_r16),
		(ASN_TAG_CLASS_CONTEXT | (46 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_trs_AdditionalBandwidth_r16_160,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"trs-AdditionalBandwidth-r16"
		},
	{ ATF_POINTER, 1, offsetof(struct BandNR, handoverIntraF_IAB_r16),
		(ASN_TAG_CLASS_CONTEXT | (47 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_handoverIntraF_IAB_r16_163,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"handoverIntraF-IAB-r16"
		},
};
static const int asn_MAP_BandNR_oms_1[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47 };
static const ber_tlv_tag_t asn_DEF_BandNR_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_BandNR_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* bandNR */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* modifiedMPR-Behaviour */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* mimo-ParametersPerBand */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* extendedCP */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* multipleTCI */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* bwp-WithoutRestriction */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* bwp-SameNumerology */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* bwp-DiffNumerology */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* crossCarrierScheduling-SameSCS */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 }, /* pdsch-256QAM-FR2 */
    { (ASN_TAG_CLASS_CONTEXT | (10 << 2)), 10, 0, 0 }, /* pusch-256QAM */
    { (ASN_TAG_CLASS_CONTEXT | (11 << 2)), 11, 0, 0 }, /* ue-PowerClass */
    { (ASN_TAG_CLASS_CONTEXT | (12 << 2)), 12, 0, 0 }, /* rateMatchingLTE-CRS */
    { (ASN_TAG_CLASS_CONTEXT | (13 << 2)), 13, 0, 0 }, /* channelBWs-DL */
    { (ASN_TAG_CLASS_CONTEXT | (14 << 2)), 14, 0, 0 }, /* channelBWs-UL */
    { (ASN_TAG_CLASS_CONTEXT | (15 << 2)), 15, 0, 0 }, /* maxUplinkDutyCycle-PC2-FR1 */
    { (ASN_TAG_CLASS_CONTEXT | (16 << 2)), 16, 0, 0 }, /* pucch-SpatialRelInfoMAC-CE */
    { (ASN_TAG_CLASS_CONTEXT | (17 << 2)), 17, 0, 0 }, /* powerBoosting-pi2BPSK */
    { (ASN_TAG_CLASS_CONTEXT | (18 << 2)), 18, 0, 0 }, /* maxUplinkDutyCycle-FR2 */
    { (ASN_TAG_CLASS_CONTEXT | (19 << 2)), 19, 0, 0 }, /* channelBWs-DL-v1590 */
    { (ASN_TAG_CLASS_CONTEXT | (20 << 2)), 20, 0, 0 }, /* channelBWs-UL-v1590 */
    { (ASN_TAG_CLASS_CONTEXT | (21 << 2)), 21, 0, 0 }, /* asymmetricBandwidthCombinationSet */
    { (ASN_TAG_CLASS_CONTEXT | (22 << 2)), 22, 0, 0 }, /* sharedSpectrumChAccessParamsPerBand-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (23 << 2)), 23, 0, 0 }, /* cancelOverlappingPUSCH-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (24 << 2)), 24, 0, 0 }, /* multipleRateMatchingEUTRA-CRS-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (25 << 2)), 25, 0, 0 }, /* overlapRateMatchingEUTRA-CRS-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (26 << 2)), 26, 0, 0 }, /* pdsch-MappingTypeB-Alt-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (27 << 2)), 27, 0, 0 }, /* oneSlotPeriodicTRS-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (28 << 2)), 28, 0, 0 }, /* olpc-SRS-Pos-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (29 << 2)), 29, 0, 0 }, /* spatialRelationsSRS-Pos-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (30 << 2)), 30, 0, 0 }, /* simulSRS-MIMO-TransWithinBand-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (31 << 2)), 31, 0, 0 }, /* channelBW-DL-IAB-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (32 << 2)), 32, 0, 0 }, /* channelBW-UL-IAB-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (33 << 2)), 33, 0, 0 }, /* rasterShift7dot5-IAB-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (34 << 2)), 34, 0, 0 }, /* ue-PowerClass-v1610 */
    { (ASN_TAG_CLASS_CONTEXT | (35 << 2)), 35, 0, 0 }, /* condHandover-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (36 << 2)), 36, 0, 0 }, /* condHandoverFailure-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (37 << 2)), 37, 0, 0 }, /* condHandoverTwoTriggerEvents-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (38 << 2)), 38, 0, 0 }, /* condPSCellChange-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (39 << 2)), 39, 0, 0 }, /* condPSCellChangeTwoTriggerEvents-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (40 << 2)), 40, 0, 0 }, /* mpr-PowerBoost-FR2-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (41 << 2)), 41, 0, 0 }, /* activeConfiguredGrant-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (42 << 2)), 42, 0, 0 }, /* jointReleaseConfiguredGrantType2-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (43 << 2)), 43, 0, 0 }, /* sps-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (44 << 2)), 44, 0, 0 }, /* jointReleaseSPS-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (45 << 2)), 45, 0, 0 }, /* simulSRS-TransWithinBand-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (46 << 2)), 46, 0, 0 }, /* trs-AdditionalBandwidth-r16 */
    { (ASN_TAG_CLASS_CONTEXT | (47 << 2)), 47, 0, 0 } /* handoverIntraF-IAB-r16 */
};
asn_SEQUENCE_specifics_t asn_SPC_BandNR_specs_1 = {
	sizeof(struct BandNR),
	offsetof(struct BandNR, _asn_ctx),
	asn_MAP_BandNR_tag2el_1,
	48,	/* Count of tags in the map */
	asn_MAP_BandNR_oms_1,	/* Optional members */
	14, 33,	/* Root/Additions */
	15,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_BandNR = {
	"BandNR",
	"BandNR",
	&asn_OP_SEQUENCE,
	asn_DEF_BandNR_tags_1,
	sizeof(asn_DEF_BandNR_tags_1)
		/sizeof(asn_DEF_BandNR_tags_1[0]), /* 1 */
	asn_DEF_BandNR_tags_1,	/* Same as above */
	sizeof(asn_DEF_BandNR_tags_1)
		/sizeof(asn_DEF_BandNR_tags_1[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_BandNR_1,
	48,	/* Elements count */
	&asn_SPC_BandNR_specs_1	/* Additional specs */
};

